{"version":3,"sources":["modules/heap.js"],"names":["MinHeap","index","Math","floor","heap","length","idx1","idx2","tmp","element","push","idx","parent","swap","root","shift","unshift","pop","heapify","left","leftChild","right","rightChild","biggest"],"mappings":";AAiEG,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA/DGA,IAAAA,EAAAA,WACU,SAAA,IAAA,EAAA,KAAA,GAgEF,EAAA,KAAA,YAAA,SAAAC,GAASA,OAAQ,EAARA,EAAY,IACpB,EAAA,KAAA,aAAA,SAAAA,GAASA,OAAQ,EAARA,EAAY,IACzB,EAAA,KAAA,SAAA,SAAAA,GAASC,OAAAA,KAAKC,OAAOF,EAAQ,GAAK,KAjEpCG,KAAAA,KAAO,GA6Db,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,UA1DD,MAAA,WACS,OAAqB,IAArB,KAAKA,KAAKC,SAyDlB,CAAA,IAAA,OAtDD,MAAA,SAAKC,EAAMC,GACHC,IAAAA,EAAM,KAAKJ,KAAKE,GACjBF,KAAAA,KAAKE,GAAQ,KAAKF,KAAKG,GACvBH,KAAAA,KAAKG,GAAQC,IAmDnB,CAAA,IAAA,OAhDD,MAAA,WACS,OAAA,KAAKJ,KAAK,KA+ClB,CAAA,IAAA,SA5CD,MAAA,SAAOK,GACAL,KAAAA,KAAKM,KAAKD,GAIRE,IAFHA,IAAAA,EAAM,KAAKP,KAAKC,OAAS,EAEd,IAARM,GAAa,KAAKP,KAAKO,GAAK,GAAK,KAAKP,KAAK,KAAKQ,OAAOD,IAAM,IAC7DE,KAAAA,KAAKF,EAAK,KAAKC,OAAOD,IAC3BA,EAAM,KAAKC,OAAOD,KAqCrB,CAAA,IAAA,aAjCD,MAAA,WAEQG,IAAAA,EAAO,KAAKV,KAAKW,QAQhBD,OAJFV,KAAAA,KAAKY,QAAQ,KAAKZ,KAAK,KAAKA,KAAKC,OAAO,IACxCD,KAAAA,KAAKa,MAELC,KAAAA,QAAQ,GACNJ,IAuBR,CAAA,IAAA,UApBD,MAAA,SAAQH,GACFQ,IAAAA,EAAO,KAAKC,UAAUT,GACtBU,EAAQ,KAAKC,WAAWX,GACxBY,EAAUZ,EAGVQ,EAAO,KAAKf,KAAKC,QAAU,KAAKD,KAAKmB,GAAS,GAAK,KAAKnB,KAAKe,GAAM,KACrEI,EAAUJ,GAIRE,EAAQ,KAAKjB,KAAKC,QAAU,KAAKD,KAAKmB,GAAS,GAAK,KAAKnB,KAAKiB,GAAO,KACvEE,EAAUF,GAIRE,GAAWZ,IACRE,KAAAA,KAAKU,EAASZ,GACdO,KAAAA,QAAQK,QAEhB,EA/DGvB,GA+DH,QAAA,QAAA","file":"heap.c34416c1.js","sourceRoot":"../src","sourcesContent":["\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  isEmpty(){\n    return this.heap.length === 0;\n  }\n\n  swap(idx1, idx2) {\n    const tmp = this.heap[idx1];\n    this.heap[idx1] = this.heap[idx2];\n    this.heap[idx2] = tmp;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  insert(element) {\n    this.heap.push(element);\n\n    let idx = this.heap.length - 1;\n\n    while (idx !== 0 && this.heap[idx][0] < this.heap[this.parent(idx)][0]) {\n      this.swap(idx, this.parent(idx));\n      idx = this.parent(idx);\n    }\n  }\n\n  extractMin() {\n    //remove ele from the front of the heap\n    const root = this.heap.shift();\n\n    //put the last element to the front of the heap and remove the last element from the\n    //heap as it is now sitting at the front of the heap\n    this.heap.unshift(this.heap[this.heap.length-1]);\n    this.heap.pop();\n\n    this.heapify(0);\n    return root;\n  }\n\n  heapify(idx) {\n    let left = this.leftChild(idx);\n    let right = this.rightChild(idx);\n    let biggest = idx;\n\n    //if left node is bigger than the current node\n    if (left < this.heap.length && this.heap[biggest][0] > this.heap[left][0]) {\n      biggest = left;\n    }\n\n    //if the right child is bigger than the curr node\n    if (right < this.heap.length && this.heap[biggest][0] > this.heap[right][0]) {\n      biggest = right;\n    }\n\n    //if the value of the smallest has changed, then swap\n    if (biggest != idx) {\n      this.swap(biggest, idx);\n      this.heapify(biggest);\n    }\n  }\n\n  leftChild = index => index * 2 + 1;\n  rightChild = index => index * 2 + 2;\n  parent = index => Math.floor((index - 1) / 2);\n}\n\n\n\nexport { MinHeap }"]}