{"version":3,"sources":["modules/heap.js","index.js"],"names":["MinHeap","index","Math","floor","heap","length","idx1","idx2","tmp","element","push","idx","parent","swap","root","shift","unshift","pop","heapify","left","leftChild","right","rightChild","biggest","grid","animationSpeed","inUse","gridSizeSlider","document","querySelector","gridWrapper","clearBtn","animationSpeedBtn","pathfindingDropdownBtn","mazeGenDroptdownBtn","Node","id","split","map","x","Number","y","visited","isWall","isStart","isEnd","DOMRef","up","down","handleRangeInputSlider","empty","createGrid","value","setStartEndNodes","clearButton","row","node","classList","remove","clearVisited","gridWidth","gridHeight","startAndEndY","startX","endX","ceil","add","startNode","endNode","HTMLElement","prototype","firstChild","removeChild","parseInt","addEventListener","window","e","target","aStar","depthFirstSearch","breadthFirstSearch","greedyBreadthFirstSearch","biDirectionalBreadthFirstSearch","generateMazeRecursiveBacktracker","generateWallsRecursiveDivisionRedone","generateWallsRandom","innerHTML","prevEle","handleMousedown","preventDefault","contains","DOMEle","buttons","gridCoords","handleMouseover","prevGridCoords","current","randInt","max","min","random","gridSize","wrapper","wrapperWidth","offsetWidth","wrapperHeight","offsetHeight","round","divWidth","toFixed","divHeight","Array","div","createElement","setAttribute","style","width","height","append","totalWalls","nodesToAnimate","i","animateNodes","generateWallsPerimiter","index1","index2","flat","filter","n","chooseOrientation","wallsToAnimate","previousHoles","forEach","yIndex","xIndex","firstYStart","firstYEnd","firstXEnd","divide","yStart","yEnd","xStart","xEnd","orient","yDivideCoord","holeCoord","xDivideCoord","manhattanDist","yCurrent","xCurrent","abs","visitedNodesToDisplay","horizDist","Infinity","prev","priorityQueue","currentHorizDist","insert","isEmpty","extractMin","currentNode","shortestPath","getShortestPath","neighbors","Object","values","getNeighbors","neighbor","newHorizDist","weight","newNeighborDist","neighborHorizDist","newGlobalCost","queue","nodesToDisplay","startNodeQueue","startNodePrev","_","startVisited","endNodeQueue","endNodePrev","endVisited","currentEndNode","currentStartNode","intersection","shortestPathStart","shortestPathEnd","concat","reverse","startNeighbors","endNeighbors","getNeighborsReversed","stack","nodesArray","type","speed","wallAnimation","transform","offset","backgroundColor","animate","setTimeout","visitedAnimation","borderRadius","pathAnimation","getRecursiveBacktrackerUnvisitedNeighbors","currentX","currentY","possibleNeighbors","startY","nodesToAddWall","next","console","log","nextY","nextX","inbetweenWall"],"mappings":"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","file":"src.e60624da.js","sourceRoot":"../src","sourcesContent":["\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  isEmpty(){\n    return this.heap.length === 0;\n  }\n\n  swap(idx1, idx2) {\n    const tmp = this.heap[idx1];\n    this.heap[idx1] = this.heap[idx2];\n    this.heap[idx2] = tmp;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  insert(element) {\n    this.heap.push(element);\n\n    let idx = this.heap.length - 1;\n\n    while (idx !== 0 && this.heap[idx][0] < this.heap[this.parent(idx)][0]) {\n      this.swap(idx, this.parent(idx));\n      idx = this.parent(idx);\n    }\n  }\n\n  extractMin() {\n    //remove ele from the front of the heap\n    const root = this.heap.shift();\n\n    //put the last element to the front of the heap and remove the last element from the\n    //heap as it is now sitting at the front of the heap\n    this.heap.unshift(this.heap[this.heap.length-1]);\n    this.heap.pop();\n\n    this.heapify(0);\n    return root;\n  }\n\n  heapify(idx) {\n    let left = this.leftChild(idx);\n    let right = this.rightChild(idx);\n    let biggest = idx;\n\n    //if left node is bigger than the current node\n    if (left < this.heap.length && this.heap[biggest][0] > this.heap[left][0]) {\n      biggest = left;\n    }\n\n    //if the right child is bigger than the curr node\n    if (right < this.heap.length && this.heap[biggest][0] > this.heap[right][0]) {\n      biggest = right;\n    }\n\n    //if the value of the smallest has changed, then swap\n    if (biggest != idx) {\n      this.swap(biggest, idx);\n      this.heapify(biggest);\n    }\n  }\n\n  leftChild = index => index * 2 + 1;\n  rightChild = index => index * 2 + 2;\n  parent = index => Math.floor((index - 1) / 2);\n}\n\n\n\nexport { MinHeap }","import { MinHeap } from './modules/heap.js'\n//internal representation of the data\nlet grid = [];\ngrid.animationSpeed = 0;\ngrid.inUse = false;\n\nconst gridSizeSlider = document.querySelector(\"#grid-size-slider\");\nconst gridWrapper = document.querySelector(\".visualiser\");\nconst clearBtn = document.querySelector('#clear-board');\nconst animationSpeedBtn = document.querySelector('#animation-speed');\n\nconst pathfindingDropdownBtn = document.querySelector('#pathfinding-dropdown');\nconst mazeGenDroptdownBtn = document.querySelector('#maze-dropdown');\n\nclass Node {\n  constructor(id) {\n    this.id = id;\n    this.index = id.split(\"-\").map(x => Number(x));\n    this.x = [...this.index][1];\n    this.y = [...this.index][0];\n    this.visited = false;\n    this.isWall = false;\n    this.isStart = false;\n    this.isEnd = false;\n    this.DOMRef;\n  }\n\n  up() {\n    if (this.y <= 0) {\n      return null;\n    } else {\n      return grid[this.y - 1][this.x];\n    }\n  }\n\n  right() {\n    if (this.x >= grid[0].length - 1) {\n      return null;\n    } else {\n      return grid[this.y][this.x + 1];\n    }\n  }\n\n  down() {\n    if (this.y >= grid.length - 1) {\n      return null;\n    } else {\n      return grid[this.y + 1][this.x];\n    }\n  }\n\n  left() {\n    if (this.x <= 0) {\n      return null;\n    } else {\n      return grid[this.y][this.x - 1];\n    }\n  }\n\n  getNeighbors() {\n    return {\n      up: this.up(),\n      right: this.right(),\n      down: this.down(),\n      left: this.left()\n    };\n  }\n\n  getNeighborsReversed() {\n    return {\n      left: this.left(),\n      down: this.down(),\n      right: this.right(),\n      up: this.up()\n    }\n  }\n}\n\n//helper method for clearing all DOM element child nodes\nHTMLElement.prototype.empty = function () {\n  while (this.firstChild) {\n    this.removeChild(this.firstChild);\n  }\n};\n\n\n\n//---------------\n//\n//EVENT LISTENER DEFS\n//\n//---------------\n\n\n//initialise grid\ncreateGrid(parseInt(gridSizeSlider.value), gridWrapper);\nsetStartEndNodes();\n\n//update grid and populte dom with divs as range slider is updated and on page load\ngridSizeSlider.addEventListener(\"input\", handleRangeInputSlider);\n\nfunction handleRangeInputSlider() {\n  grid.length = 0;\n  gridWrapper.empty();\n  createGrid(Number(gridSizeSlider.value), gridWrapper);\n  setStartEndNodes();\n}\n\nwindow.addEventListener('resize', handleRangeInputSlider);\n\npathfindingDropdownBtn.addEventListener('click', e => {\n  switch (e.target.value) {\n    case \"a*\":\n      clearVisited();\n      aStar();\n      break;\n    case \"dfs\":\n      clearVisited();\n      depthFirstSearch()\n      break;\n    case \"bfs\":\n      clearVisited();\n      breadthFirstSearch();\n      break;\n    case \"gbfs\":\n      clearVisited();\n      greedyBreadthFirstSearch();\n      break;\n    case \"bdbfs\":\n      clearVisited();\n      biDirectionalBreadthFirstSearch();\n      break;\n\n    default:\n      return;\n  }\n});\n\nmazeGenDroptdownBtn.addEventListener('click', e => {\n  switch (e.target.id) {\n    case 'recursive-backtracker':\n      clearButton();\n      generateMazeRecursiveBacktracker(5, 5);\n      break;\n    case 'recursive-division':\n      clearButton();\n      generateWallsRecursiveDivisionRedone();\n      break;\n    case 'random-walls':\n      clearButton();\n      generateWallsRandom();\n      break;\n    default:\n      return;\n  }\n});\n\nanimationSpeedBtn.addEventListener('click', e => {\n  switch (e.target.value) {\n    case 'fast':\n      //change from fastto slow on click\n      e.target.value = 'slow';\n      e.target.innerHTML = 'Animation Speed: Slow'\n      grid.animationSpeed = 15;\n      break;\n\n    case 'slow':\n      //change from slow to none on click\n      e.target.value = 'instant';\n      e.target.innerHTML = 'Animation Speed: None';\n      grid.animationSpeed = 0;\n      break;\n\n    default:\n      //change from instant to fast on click\n      e.target.value = 'fast';\n      e.target.innerHTML = 'Animation Speed: Fast';\n      grid.animationSpeed = 5;\n      break;\n  }\n});\n\nclearBtn.addEventListener('click', clearButton);\n\nfunction clearButton() {\n  grid.map(row => row.map(node => {\n    node.isWall = false;\n    node.visited = false;\n    node.DOMRef.classList.remove('wall-node');\n    node.DOMRef.classList.remove('visited');\n    node.DOMRef.classList.remove('path-node');\n  }))\n}\n\nfunction clearVisited() {\n  grid.map(row => row.map(node => {\n    node.visited = false;\n    node.DOMRef.classList.remove('visited');\n    node.DOMRef.classList.remove('path-node');\n  }))\n}\n\n\n\nfunction setStartEndNodes() {\n  const gridWidth = grid[0].length - 1;\n  const gridHeight = grid.length - 1\n\n  const startAndEndY = Math.floor(gridHeight / 2);\n  const startX = Math.floor(0.15 * gridWidth);\n  const endX = Math.ceil(0.85 * gridWidth);\n\n  grid[startAndEndY][startX].isStart = true;\n  grid[startAndEndY][startX].DOMRef.classList.add('start-node');\n  grid.startNode = [startAndEndY, startX];\n\n  grid[startAndEndY][endX].isEnd = true;\n  grid[startAndEndY][endX].DOMRef.classList.add('end-node');\n  grid.endNode = [startAndEndY, endX];\n\n}\n\n\n\n//inital value. would prefer to initialise to nothing but is janky unless I do this\nlet prevEle = gridWrapper.querySelector('div[id=\"0-0\"]');\n\ngridWrapper.addEventListener('mousedown', handleMousedown);\n\nfunction handleMousedown(e) {\n  e.preventDefault();\n  if (!e.target.classList.contains('visualiser')) {\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n      gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`).classList.add('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = true;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n      gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`).classList.remove('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = false;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isStart) {\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isEnd) {\n      prevEle = DOMEle;\n    }\n  }\n}\n\n\n\ngridWrapper.addEventListener('mouseover', handleMouseover);\n\nfunction handleMouseover(e) {\n  if (!e.target.classList.contains('visualiser')) {\n\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.target != prevEle) {\n      if (e.buttons === 1 && prevEle.classList.contains('start-node')) {\n        prevEle.classList.remove('start-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isStart = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n\n        current.classList.add('start-node');\n        grid[gridCoords[0]][gridCoords[1]].isStart = true;\n        grid.startNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n      } else if (e.buttons === 1 && prevEle.classList.contains('end-node')) {\n        prevEle.classList.remove('end-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isEnd = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n        current.classList.add('end-node');\n        grid[gridCoords[0]][gridCoords[1]].isEnd = true;\n        grid.endNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n      } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n        gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`).classList.remove('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n        prevEle = DOMEle;\n\n      } else if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n        gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`).classList.add('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = true;\n        prevEle = DOMEle;\n      }\n    }\n  }\n}\n\n\n//---------------------------------------------\n//\n//GRAPH ALGO'S\n//\n//---------------------------------------------\n\nfunction randInt(max, min = 0) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction createGrid(gridSize, wrapper) {\n  const wrapperWidth = wrapper.offsetWidth;\n  const wrapperHeight = wrapper.offsetHeight;\n\n  const gridWidth = gridSize;\n  const gridHeight = Math.round(gridSize * 0.45);\n\n  const divWidth = (wrapperWidth / gridWidth).toFixed(3);\n  const divHeight = (wrapperHeight / gridHeight).toFixed(3);\n\n  for (let y = 0; y < gridHeight; y++) {\n    grid.push(new Array());\n    for (let x = 0; x < gridWidth; x++) {\n      const div = document.createElement(\"div\");\n      div.classList.add(\"node\");\n      div.setAttribute(\"id\", y + \"-\" + x);\n      div.style.width = divWidth + \"px\";\n      div.style.height = divHeight + \"px\";\n      wrapper.append(div);\n\n      grid[y].push(new Node(`${y}-${x}`));\n      grid[y][x].DOMRef = div;\n    }\n  }\n}\n\nfunction generateWallsRandom() {\n  const height = grid.length - 1;\n  const width = grid[0].length - 1\n\n  const totalWalls = (height * width) / 3;\n  const nodesToAnimate = [];\n\n  for (let i = 0; i < totalWalls; i++) {\n    const y = randInt(height);\n    const x = randInt(width);\n    if (grid[y][x].isWall || grid[y][x].isStart || grid[y][x].isEnd) {\n      i--;\n    } else {\n      nodesToAnimate.push(grid[y][x])\n    }\n  }\n  animateNodes(nodesToAnimate, 'wall');\n}\n\nfunction generateWallsPerimiter() {\n  const nodesToAnimate = grid.map((row, index1) => row.map((node, index2) => {\n\n    if (index1 === 0 || index1 === grid.length - 1) {\n      return node\n    } else if (index2 === 0 || index2 === row.length - 1) {\n      return node\n    }\n  }))\n    .flat()\n    .filter(n => n);\n\n  animateNodes(nodesToAnimate, 'wall')\n}\n\nfunction chooseOrientation(width, height) {\n  if (width < height) {\n    return \"horizontal\";\n  } else if (height < width) {\n    return \"vertical\";\n  } else {\n    return Math.floor(Math.random() * 2) ? \"horizontal\" : \"vertical\";\n  }\n}\n\nfunction generateWallsRecursiveDivisionRedone() {\n  const wallsToAnimate = [];\n  const previousHoles = grid.map(row => row.map(node => false));\n\n  grid.forEach((row, yIndex) => row.forEach((node, xIndex) => {\n    if (yIndex === 0 || yIndex === grid.length - 1) wallsToAnimate.push(node);\n    else if (xIndex === 0 || xIndex === row.length - 1) wallsToAnimate.push(node);\n  }));\n\n  // const reversedBottomRow = wallsToAnimate.splice(-grid[0].length).reverse();\n\n  // wallsToAnimate.concat(reversedBottomRow);\n\n  // console.log(wallsToAnimate);\n\n\n\n  const firstYStart = 1;\n  const firstYEnd = grid.length - 2;\n  const firstXStart = 1;\n  const firstXEnd = grid[0].length - 2;\n\n  const orientation = chooseOrientation(firstXEnd - firstXStart, firstYEnd - firstYStart);\n\n  divide(firstYStart, firstYEnd, firstXStart, firstXEnd, orientation);\n\n  animateNodes(wallsToAnimate, 'wall');\n\n\n  function divide(yStart, yEnd, xStart, xEnd, orient) {\n    const width = xEnd - xStart + 1;\n    const height = yEnd - yStart + 1;\n\n    //prevents walls right next to eachother\n    if (width < 2 || height < 2 || height * width < 5) return;\n\n    if (orient == 'horizontal') {\n      const yDivideCoord = randInt(yEnd - 1, yStart + 1);\n      let holeCoord\n\n      if (previousHoles[yDivideCoord][xStart - 1]) {\n        holeCoord = xStart;\n      } else if (previousHoles[yDivideCoord][xEnd + 1]) {\n        holeCoord = xEnd;\n      } else {\n        holeCoord = Math.random() > .5 ? xStart : xEnd;\n        // holeCoord = randInt(xEnd, xStart);\n      }\n\n      for (let i=xStart; i <= xEnd; i++) {\n        if (grid[yDivideCoord][i].isStart || grid[yDivideCoord][i].isEnd || i === holeCoord){\n          previousHoles[yDivideCoord][i] = true;\n        }\n        if (previousHoles[yDivideCoord][i]) continue;\n\n        wallsToAnimate.push(grid[yDivideCoord][i]);\n      }\n\n      //topside\n      let orient = chooseOrientation(width, yDivideCoord - yStart);\n      divide(yStart, yDivideCoord-1, xStart, xEnd, orient);\n\n      //bottomside\n      orient = chooseOrientation(width, yEnd - yDivideCoord);\n      divide(yDivideCoord+1, yEnd, xStart, xEnd, orient);\n\n\n    } else {\n      const xDivideCoord = randInt(xEnd - 1, xStart + 1);\n\n      let holeCoord;\n      if (previousHoles[yStart-1][xDivideCoord]) {\n        holeCoord = yStart;\n      } else if (previousHoles[yEnd+1][xDivideCoord]) {\n        holeCoord = yEnd;\n      } else {\n        holeCoord = Math.random() > .5 ? yStart : yEnd;\n        // holeCoord = randInt(yEnd, yStart);\n      }\n\n      for (let i=yStart; i <= yEnd; i++) {\n\n        if (grid[i][xDivideCoord].isStart || grid[i][xDivideCoord].isEnd || i === holeCoord){\n          previousHoles[i][xDivideCoord] = true;\n        }\n        if (previousHoles[i][xDivideCoord]) continue;\n\n        wallsToAnimate.push(grid[i][xDivideCoord]);\n      }\n\n      //divide left side\n      let orient = chooseOrientation(xDivideCoord - xStart, height);\n      divide(yStart, yEnd, xStart, xDivideCoord-1, orient);\n\n      //divide right side\n      orient = chooseOrientation(xEnd - xDivideCoord, height);\n      divide(yStart, yEnd, xDivideCoord+1, xEnd, orient);\n    }\n  }\n}\n\nfunction manhattanDist(yCurrent, xCurrent, yEnd, xEnd) {\n  return Math.abs((yEnd - yCurrent)) + Math.abs((xEnd - xCurrent))\n}\n\nfunction greedyBreadthFirstSearch() {\n  const visitedNodesToDisplay = [];\n  const visited = grid.map(row => row.map(node => false));\n  const horizDist = grid.map(row => row.map(node => Infinity));\n  const prev = grid.map(row => row.map(node => null));\n\n  const priorityQueue = new MinHeap;\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  let currentHorizDist = manhattanDist(startNode.y, startNode.x, endNode.y, endNode.x);\n\n  priorityQueue.insert([currentHorizDist, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentHorizDist, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      animateNodes(visitedNodesToDisplay, 'visited');\n      animateNodes(shortestPath, 'path');\n      return\n    };\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      let newHorizDist = manhattanDist(neighbor.y, neighbor.x, endNode.y, endNode.x);\n      if (newHorizDist < horizDist[neighbor.y][neighbor.x]) {\n        horizDist[neighbor.y][neighbor.x] = newHorizDist;\n        priorityQueue.insert([newHorizDist, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n  animateNodes(visitedNodesToDisplay, 'visited');\n}\n\nfunction aStar() {\n  const visitedNodesToDisplay = [];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n\n  const visited = grid.map(row => row.map(node => false));\n  const prev = grid.map(row => row.map(node => null));\n  const horizDist = grid.map(row => row.map(node => Infinity));\n\n  horizDist[startNode.y][startNode.x] = 0;\n  const weight = 1\n  let currentHorizDist = manhattanDist(startNode.y, startNode.x, endNode.y, endNode.x);\n\n\n\n  const priorityQueue = new MinHeap;\n  priorityQueue.insert([0, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentGlobalCost, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      animateNodes(visitedNodesToDisplay, 'visited');\n      animateNodes(shortestPath, 'path');\n      break;\n    };\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => n && !n.isWall);\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      const newNeighborDist = horizDist[currentNode.y][currentNode.x] + weight;\n      const neighborHorizDist = manhattanDist(neighbor.y, neighbor.x, endNode.y, endNode.x);\n      const newGlobalCost = newNeighborDist + neighborHorizDist;\n      // console.log( newNeighborDist, neighborHorizDist, newGlobalCost);\n\n      if (newGlobalCost < horizDist[neighbor.y][neighbor.x] + neighborHorizDist) {\n        horizDist[neighbor.y][neighbor.x] = newNeighborDist;\n        priorityQueue.insert([newGlobalCost, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n\n\n    }\n  }\n  animateNodes(visitedNodesToDisplay, 'visited');\n}\n\nfunction breadthFirstSearch() {\n  const queue = [];\n  const nodesToDisplay = []\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map(row => row.map(n => null));\n  const visited = grid.map(row => row.map(n => false));\n\n  queue.push(startNode);\n\n  while (queue.length) {\n    let currentNode = queue.shift();\n    visited[currentNode.y][currentNode.x] = true;\n\n    // nodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      animateNodes(nodesToDisplay, 'visited');\n      animateNodes(shortestPath, 'path');\n\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => {\n      if (n && !n.isWall) return n\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      visited[neighbor.y][neighbor.x] = true;\n      nodesToDisplay.push(neighbor)\n      // neighbor.DOMRef.classList.add('visited');\n      prev[neighbor.y][neighbor.x] = currentNode;\n      queue.push(neighbor);\n    }\n  }\n  animateNodes(nodesToDisplay, 'visited');\n}\n\nfunction biDirectionalBreadthFirstSearch() {\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const nodesToDisplay = [];\n\n  const startNodeQueue = [];\n  const startNodePrev = grid.map(row => row.map(_ => null));\n  const startVisited = grid.map(row => row.map(_ => false));\n  startNodeQueue.push(startNode);\n\n\n  const endNodeQueue = [];\n  const endNodePrev = grid.map(row => row.map(_ => null));\n  const endVisited = grid.map(row => row.map(_ => false));\n  endNodeQueue.push(endNode);\n\n  while (endNodeQueue.length && startNodeQueue.length) {\n    const currentEndNode = endNodeQueue.shift();\n    const currentStartNode = startNodeQueue.shift();\n    let intersection;\n\n    for (let y = 0; y < startVisited.length; y++) {\n      for (let x = 0; x < startVisited[0].length; x++) {\n        if (startVisited[y][x] && endVisited[y][x]) {\n          intersection = grid[y][x];\n          break;\n        }\n      }\n    }\n\n    if (intersection) {\n      animateNodes(nodesToDisplay, 'visited');\n      const shortestPathStart = getShortestPath(intersection, startNodePrev, startNode);\n      const shortestPathEnd = getShortestPath(intersection, endNodePrev, endNode);\n      shortestPathStart.push(intersection);\n      animateNodes(shortestPathStart.concat(shortestPathEnd.reverse()), 'path');\n      return\n    }\n\n    const startNeighbors = Object.values(currentStartNode.getNeighbors()).filter(n => n && !n.isWall);\n    const endNeighbors = Object.values(currentEndNode.getNeighborsReversed()).filter(n => n && !n.isWall);\n\n    for (let neighbor of startNeighbors) {\n      if (startVisited[neighbor.y][neighbor.x]) continue;\n\n      startVisited[neighbor.y][neighbor.x] = true;\n      nodesToDisplay.push(neighbor);\n      startNodePrev[neighbor.y][neighbor.x] = currentStartNode;\n      startNodeQueue.push(neighbor);\n    }\n\n    for (let neighbor of endNeighbors) {\n      if (endVisited[neighbor.y][neighbor.x]) continue;\n\n      endVisited[neighbor.y][neighbor.x] = true;\n      nodesToDisplay.push(neighbor);\n      endNodePrev[neighbor.y][neighbor.x] = currentEndNode;\n      endNodeQueue.push(neighbor);\n    }\n  }\n\n  animateNodes(nodesToDisplay, 'visited');\n}\n\nfunction depthFirstSearch() {\n  const stack = [];\n  const nodesToDisplay = [];\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map(row => row.map(n => null));\n  const visited = grid.map(row => row.map(n => false));\n  visited[startNode.y][startNode.x];\n\n  stack.push(startNode);\n\n  while (stack.length) {\n    const currentNode = stack.pop();\n    visited[currentNode.y][currentNode.x] = true;\n    nodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      animateNodes(nodesToDisplay, 'visited');\n      animateNodes(shortestPath, 'path');\n      return;\n    }\n\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n\n      prev[neighbor.y][neighbor.x] = currentNode;\n      stack.push(neighbor);\n      // break;\n    }\n  }\n  animateNodes(nodesToDisplay, 'visited');\n}\n\nfunction getShortestPath(currentNode, prev, startNode) {\n  const shortestPath = [];\n  while (true) {\n    if (prev[currentNode.y][currentNode.x] == startNode) break;\n\n    shortestPath.unshift(prev[currentNode.y][currentNode.x])\n    currentNode = prev[currentNode.y][currentNode.x]\n  }\n  return shortestPath\n}\n\nfunction animateNodes(nodesArray, type, reverse = false) {\n  const speed = grid.animationSpeed;\n\n  switch (type) {\n    case 'wall':\n      let wallAnimation;\n      (reverse) ? wallAnimation =\n        [{ transform: 'scale(1.2)', offset: 0.75 }, { backgroundColor: 'hsl(0, 0%, 100%)' }]\n        : [{ transform: 'scale(1.2)', offset: 0.75 }, { backgroundColor: 'hsla(240, 23%, 8%, 0.9)' }];\n\n      for (let i = 0; i < nodesArray.length; i++) {\n        const currentNode = nodesArray[i];\n        if (speed === 0) {\n          (reverse) ? currentNode.isWall = false : currentNode.isWall = true;\n          (reverse) ? currentNode.DOMRef.classList.remove('wall-node') : currentNode.DOMRef.classList.add('wall-node');\n          (reverse) ? currentNode.DOMRef.animate(wallAnimation, 400) : currentNode.DOMRef.animate(wallAnimation, 400);\n        } else {\n          setTimeout(() => {\n            (reverse) ? currentNode.isWall = false : currentNode.isWall = true;\n            (reverse) ? currentNode.DOMRef.classList.remove('wall-node') : currentNode.DOMRef.classList.add('wall-node');\n            (reverse) ? currentNode.DOMRef.animate(wallAnimation, 400) : currentNode.DOMRef.animate(wallAnimation, 400);\n          }, speed * i);\n        }\n      }\n      return true;\n\n    case 'visited':\n\n      const visitedAnimation = [{ transform: 'scale(.2)' },\n      { borderRadius: '50%', backgroundColor: 'hsl(281, 53%, 24%)', offset: 0.25 },\n      { transform: 'scale(1.2)', offset: 0.7 }];\n\n      for (let i = 0; i < nodesArray.length; i++) {\n        const currentNode = nodesArray[i];\n        if (speed === 0) {\n          currentNode.visited = true;\n          currentNode.DOMRef.classList.add('visited');\n        } else {\n          setTimeout(() => {\n            currentNode.visited = true;\n            currentNode.DOMRef.classList.add('visited');\n            currentNode.DOMRef.animate(visitedAnimation, 500);\n          }, speed * i);\n        }\n      }\n      return true;\n\n    case 'path':\n\n      const pathAnimation = [{ transform: 'scale(.5)' }, { backgroundColor: 'hsla(115, 41%, 30%, 0.397)', offset: .5 }, { transform: 'scale(1.2)', offset: .75 }];\n      for (let i = 0; i < nodesArray.length; i++) {\n        const node = nodesArray[i];\n        if (speed === 0) {\n          node.DOMRef.classList.add('path-node');\n        } else {\n          setTimeout(() => {\n            node.DOMRef.classList.add('path-node');\n            node.DOMRef.animate(pathAnimation, 500);\n          }, speed * i)\n        }\n      }\n      ;\n\n    default:\n      return;\n  }\n}\n\nfunction getRecursiveBacktrackerUnvisitedNeighbors(currentX, currentY, visited) {\n  let possibleNeighbors = [\n    [currentY - 2, currentX],\n    [currentY, currentX + 2],\n    [currentY + 2, currentX],\n    [currentY, currentX - 2]\n  ];\n\n  let neighbors = [];\n\n  for (let i = 0; i < possibleNeighbors.length; i++) {\n    let [y, x] = possibleNeighbors[i];\n    if (y < 0 || y > grid.length - 1 || x < 0 || x > grid[0].length - 1) continue;\n    if (visited[y][x]) continue;\n\n    neighbors.push([y, x]);\n  }\n  if (neighbors.length > 0) {\n    const nextIdx = Math.floor(Math.random() * neighbors.length);\n    return neighbors[nextIdx];\n  } else {\n    return\n  }\n}\n\nfunction generateMazeRecursiveBacktracker(startX, startY) {\n  grid.map(row => row.map(node => {\n    if (node.isStart || node.isEnd) return;\n\n    node.isWall = true;\n    node.DOMRef.classList.add('wall-node');\n  }));\n\n  const visited = grid.map(row => row.map(_ => false));\n  visited[startY][startX] = true;\n\n  const nodesToAddWall = [];\n  const stack = [];\n  let [currentY, currentX] = [startY, startX];\n\n  while (true) {\n\n    let next = getRecursiveBacktrackerUnvisitedNeighbors(currentX, currentY, visited);\n    console.log('next[Y, X] ' + next);\n    nodesToAddWall.push(grid[currentY][currentX]);\n\n    if (next) {\n      stack.push(next);\n\n      let [nextY, nextX] = next;\n      visited[nextY][nextX] = true;\n      let inbetweenWall;\n      if (currentX === nextX) {\n        if (currentY > nextY) {\n          inbetweenWall = [currentY - 1, currentX]\n        } else {\n          inbetweenWall = [currentY + 1, currentX]\n        }\n      } else if (currentY === nextY) {\n        if (currentX > nextX) {\n          inbetweenWall = [currentY, currentX - 1]\n        } else {\n          inbetweenWall = [currentY, currentX + 1]\n        }\n      }\n\n      nodesToAddWall.push(grid[inbetweenWall[0]][inbetweenWall[1]]);\n\n      currentY = nextY;\n      currentX = nextX;\n    } else {\n      console.log('no next')\n      if (stack.length > 0) {\n        next = stack.pop();\n\n        [currentY, currentX] = next;\n      } else {\n        break;\n      }\n\n\n    }\n  }\n  animateNodes(nodesToAddWall, 'wall', true)\n}\n\n/* function djikstra() {\n  const visited = grid.map(row => row.map(node => false));\n  const weight = grid.map(row => row.map(node => (node.isWeight) ? 10 : 1 ));\n  const dist = grid.map(row => row.map(node => Infinity));\n  const prev = grid.map(row => row.map(node => null));\n  const visitedNodesToDisplay = [];\n\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n\n  dist[startNode.y][startNode.x] = 0;\n  const priorityQueue = new MinHeap;\n\n  priorityQueue.insert([0, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentDist, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n    console.log(priorityQueue.heap);\n\n\n\n    if (currentNode == endNode) {\n      animateNodes(visitedNodesToDisplay, 'visited');\n      console.log(prev);\n      break;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (const neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) {\n        console.log('passed');\n        continue;\n      }\n\n      let newDistance = currentDist + weight[neighbor.y][neighbor.x];\n\n      if (newDistance < dist[neighbor.y][neighbor.x]) {\n        dist[neighbor.y][neighbor.x] = newDistance;\n        priorityQueue.insert([newDistance, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n\n} */"]}