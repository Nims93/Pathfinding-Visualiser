{"version":3,"sources":["modules/heap.js","index.js"],"names":["MinHeap","index","Math","floor","heap","length","idx1","idx2","tmp","element","push","idx","parent","swap","root","shift","unshift","pop","heapify","left","leftChild","right","rightChild","biggest","grid","animationSpeed","canMutate","previousAlgo","gridSizeSlider","document","querySelector","gridWrapper","clearBtn","animationSpeedBtn","pathfindingDropdownBtn","mazeGenDroptdownBtn","tutorialBtn","Node","id","split","map","n","Number","x","y","visited","isWall","isStart","isEnd","DOMRef","up","down","createGrid","gridSize","visualiserWrapper","wrapperWidth","clientWidth","wrapperHeight","clientHeight","gridWidth","gridHeight","divWidth","toFixed","divHeight","Array","div","createElement","classList","add","setAttribute","style","width","height","append","handleGridSizeInputSlider","empty","parseInt","value","setStartEndNodes","clearBoard","row","node","remove","clearVisited","startAndEndY","startX","endX","ceil","startNode","endNode","HTMLElement","prototype","firstChild","removeChild","addEventListener","window","e","target","aStar","depthFirstSearch","breadthFirstSearch","greedyBreadthFirstSearch","biDirectionalBreadthFirstSearch","generateMazeRecursiveBacktracker","generateWallsRecursiveDivision","generateWallsRandom","innerHTML","prevEle","handleMousedown","preventDefault","contains","DOMEle","buttons","gridCoords","handleMouseover","prevGridCoords","current","findPathOnStartOrEndNodeMouseDrag","prevAnimationSpeed","closeTutorialBtnArray","querySelectorAll","tutorialTransparencyLayer","tutorialNextAndPrevBtns","btn","handleNextAndPreTutorialClick","pageChangeBtn","currentTarget","tutorialWrapper","i","children","currVisChildIdx","randInt","max","min","random","totalWalls","nodesToAnimate","animateNodes","chooseOrientation","wallsToAnimate","previousHoles","forEach","yIndex","xIndex","firstYStart","firstYEnd","firstXEnd","divide","yStart","yEnd","xStart","xEnd","orient","yDivideCoord","holeCoord","xDivideCoord","getRecursiveBacktrackerUnvisitedNeighbors","currentX","currentY","possibleNeighbors","neighbors","startY","_","nodesToAddWall","stack","next","nextY","nextX","inbetweenWall","manhattanDist","yCurrent","xCurrent","abs","visitedNodesToDisplay","horizDist","Infinity","prev","priorityQueue","currentHorizDist","insert","isEmpty","extractMin","currentNode","shortestPath","getShortestPath","concat","Object","values","getNeighbors","filter","neighbor","newHorizDist","weight","newNeighborDist","neighborHorizDist","newGlobalCost","queue","startNodeQueue","startNodePrev","startVisited","endNodeQueue","endNodePrev","endVisited","currentEndNode","currentStartNode","intersection","shortestPathStart","shortestPathEnd","pathNodesToDisplay","reverse","startNeighbors","endNeighbors","getNeighborsReversed","prevArray","nodesArray","removeWallAnimation","nodeTypeToAnimate","transform","offset","backgroundColor","wallAnimation","visitedAnimation","borderRadius","pathAnimation","speed","setTimeout","animate","includes"],"mappings":"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","file":"src.171fb4f9.js","sourceRoot":"../src","sourcesContent":["\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  isEmpty(){\n    return this.heap.length === 0;\n  }\n\n  swap(idx1, idx2) {\n    const tmp = this.heap[idx1];\n    this.heap[idx1] = this.heap[idx2];\n    this.heap[idx2] = tmp;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  insert(element) {\n    this.heap.push(element);\n\n    let idx = this.heap.length - 1;\n\n    while (idx !== 0 && this.heap[idx][0] < this.heap[this.parent(idx)][0]) {\n      this.swap(idx, this.parent(idx));\n      idx = this.parent(idx);\n    }\n  }\n\n  extractMin() {\n    //remove ele from the front of the heap\n    const root = this.heap.shift();\n\n    //put the last element to the front of the heap and remove the last element from the\n    //heap as it is now sitting at the front of the heap\n    this.heap.unshift(this.heap[this.heap.length-1]);\n    this.heap.pop();\n\n    this.heapify(0);\n    return root;\n  }\n\n  heapify(idx) {\n    let left = this.leftChild(idx);\n    let right = this.rightChild(idx);\n    let biggest = idx;\n\n    //if left node is bigger than the current node\n    if (left < this.heap.length && this.heap[biggest][0] > this.heap[left][0]) {\n      biggest = left;\n    }\n\n    //if the right child is bigger than the curr node\n    if (right < this.heap.length && this.heap[biggest][0] > this.heap[right][0]) {\n      biggest = right;\n    }\n\n    //if the value of the smallest has changed, then swap\n    if (biggest != idx) {\n      this.swap(biggest, idx);\n      this.heapify(biggest);\n    }\n  }\n\n  leftChild = index => index * 2 + 1;\n  rightChild = index => index * 2 + 2;\n  parent = index => Math.floor((index - 1) / 2);\n}\n\n\n\nexport { MinHeap }","import { MinHeap } from './modules/heap.js';\n\n//background representation of displayed grid\nlet grid = [];\ngrid.animationSpeed = 5;\ngrid.canMutate = true;\ngrid.previousAlgo = null;\n\nconst gridSizeSlider = document.querySelector('#grid-size-slider');\nconst gridWrapper = document.querySelector('.visualiser');\nconst clearBtn = document.querySelector('#clear-board');\nconst animationSpeedBtn = document.querySelector('#animation-speed');\n\nconst pathfindingDropdownBtn = document.querySelector('#pathfinding-dropdown');\nconst mazeGenDroptdownBtn = document.querySelector('#maze-dropdown');\n\nconst tutorialBtn = document.querySelector('#help');\n\n//class represents each node/vertex in grid\nclass Node {\n  constructor(id) {\n    this.id = id;\n    this.index = id.split('-').map((n) => Number(n));\n    this.x = [...this.index][1];\n    this.y = [...this.index][0];\n    this.visited = false;\n    this.isWall = false;\n    this.isStart = false;\n    this.isEnd = false;\n    this.DOMRef;\n  }\n\n  up() {\n    if (this.y <= 0) {\n      return null;\n    } else {\n      return grid[this.y - 1][this.x];\n    }\n  }\n\n  right() {\n    if (this.x >= grid[0].length - 1) {\n      return null;\n    } else {\n      return grid[this.y][this.x + 1];\n    }\n  }\n\n  down() {\n    if (this.y >= grid.length - 1) {\n      return null;\n    } else {\n      return grid[this.y + 1][this.x];\n    }\n  }\n\n  left() {\n    if (this.x <= 0) {\n      return null;\n    } else {\n      return grid[this.y][this.x - 1];\n    }\n  }\n\n  getNeighbors() {\n    return {\n      up: this.up(),\n      right: this.right(),\n      down: this.down(),\n      left: this.left(),\n    };\n  }\n\n  getNeighborsReversed() {\n    return {\n      left: this.left(),\n      down: this.down(),\n      right: this.right(),\n      up: this.up(),\n    };\n  }\n}\n\n//helper method for clearing all DOM element child nodes\nHTMLElement.prototype.empty = function () {\n  while (this.firstChild) {\n    this.removeChild(this.firstChild);\n  }\n};\n\n//----------------------------------------------------------\n//\n//\n//EVENT LISTENERS & UI FUNCTIONS\n//\n//\n//------------------------------------------------------------\n\n//initialise grid\ngrid.canMutate = false;\ncreateGrid(parseInt(gridSizeSlider.value), gridWrapper);\nsetStartEndNodes();\ngrid.canMutate = true;\n\nfunction createGrid(gridSize, visualiserWrapper) {\n  const wrapperWidth = visualiserWrapper.clientWidth;\n  const wrapperHeight = visualiserWrapper.clientHeight;\n\n  const gridWidth = gridSize;\n  const gridHeight = Math.floor(gridSize * 0.45);\n  // console.log(wrapperWidth);\n\n  const divWidth = (wrapperWidth / gridWidth).toFixed(3);\n  const divHeight = (wrapperHeight / gridHeight).toFixed(3);\n\n  for (let y = 0; y < gridHeight; y++) {\n    grid.push(new Array());\n    for (let x = 0; x < gridWidth; x++) {\n      const div = document.createElement('div');\n      div.classList.add('node');\n      div.setAttribute('id', y + '-' + x);\n      div.style.width = divWidth + 'px';\n      div.style.height = divHeight + 'px';\n      visualiserWrapper.append(div);\n\n      grid[y].push(new Node(`${y}-${x}`));\n      grid[y][x].DOMRef = div;\n    }\n  }\n}\n\n//update grid and populte dom with divs as range slider is updated and on page load\ngridSizeSlider.addEventListener('input', handleGridSizeInputSlider);\n\nfunction handleGridSizeInputSlider() {\n  if (grid.canMutate) {\n    grid.canMutate = false;\n    grid.length = 0;\n    gridWrapper.empty();\n    createGrid(parseInt(gridSizeSlider.value), gridWrapper);\n    setStartEndNodes();\n    grid.canMutate = true;\n  }\n}\n\nwindow.addEventListener('resize', handleGridSizeInputSlider);\n\npathfindingDropdownBtn.addEventListener('click', (e) => {\n  if (grid.canMutate) {\n    grid.canMutate = false;\n    switch (e.target.value) {\n      case 'a*':\n        grid.previousAlgo = 'a*';\n        clearVisited();\n        aStar();\n        break;\n      case 'dfs':\n        grid.previousAlgo = 'dfs';\n        clearVisited();\n        depthFirstSearch();\n        break;\n      case 'bfs':\n        grid.previousAlgo = 'bfs';\n        clearVisited();\n        breadthFirstSearch();\n        break;\n      case 'gbfs':\n        grid.previousAlgo = 'gbfs';\n        clearVisited();\n        greedyBreadthFirstSearch();\n        break;\n      case 'bdbfs':\n        grid.previousAlgo = 'bdbfs';\n        clearVisited();\n        biDirectionalBreadthFirstSearch();\n        break;\n\n      default:\n        return;\n    }\n  }\n});\n\nmazeGenDroptdownBtn.addEventListener('click', (e) => {\n  if (grid.canMutate) {\n    grid.canMutate = false;\n    switch (e.target.id) {\n      case 'recursive-backtracker':\n        clearBoard();\n        generateMazeRecursiveBacktracker(5, 5);\n        break;\n      case 'recursive-division':\n        clearBoard();\n        generateWallsRecursiveDivision();\n        break;\n      case 'random-walls':\n        clearBoard();\n        generateWallsRandom();\n        break;\n      default:\n        return;\n    }\n  }\n});\n\nanimationSpeedBtn.addEventListener('click', (e) => {\n  switch (e.target.value) {\n    case 'fast':\n      //change from fast to slow on click\n      e.target.value = 'slow';\n      e.target.innerHTML = 'Animations: Slow';\n      grid.animationSpeed = 15;\n      break;\n\n    case 'slow':\n      //change from slow to none on click\n      e.target.value = 'instant';\n      e.target.innerHTML = 'Animations: None';\n      grid.animationSpeed = 0;\n      break;\n\n    default:\n      //change from none to fast on click\n      e.target.value = 'fast';\n      e.target.innerHTML = 'Animations: Fast';\n      grid.animationSpeed = 5;\n      break;\n  }\n});\n\nclearBtn.addEventListener('click', () => {\n  if (grid.canMutate) {\n    grid.previousAlgo = null;\n    clearBoard();\n  }\n});\n\nfunction clearBoard() {\n  grid.map((row) =>\n    row.map((node) => {\n      node.isWall = false;\n      node.visited = false;\n      node.DOMRef.classList.remove('wall-node');\n      node.DOMRef.classList.remove('visited');\n      node.DOMRef.classList.remove('path-node');\n    })\n  );\n}\n\nfunction clearVisited() {\n  grid.map((row) =>\n    row.map((node) => {\n      node.visited = false;\n      node.DOMRef.classList.remove('visited');\n      node.DOMRef.classList.remove('path-node');\n    })\n  );\n}\n\nfunction setStartEndNodes() {\n  const gridWidth = grid[0].length - 1;\n  const gridHeight = grid.length - 1;\n\n  const startAndEndY = Math.floor(gridHeight / 2);\n  const startX = Math.floor(0.15 * gridWidth);\n  const endX = Math.ceil(0.85 * gridWidth);\n\n  grid[startAndEndY][startX].isStart = true;\n  grid[startAndEndY][startX].DOMRef.classList.add('start-node');\n  grid.startNode = [startAndEndY, startX];\n\n  grid[startAndEndY][endX].isEnd = true;\n  grid[startAndEndY][endX].DOMRef.classList.add('end-node');\n  grid.endNode = [startAndEndY, endX];\n}\n\n//inital value\nlet prevEle = gridWrapper.querySelector('div[id=\"0-0\"]');\n\ngridWrapper.addEventListener('mousedown', handleMousedown);\n\nfunction handleMousedown(e) {\n  e.preventDefault();\n  if (!e.target.classList.contains('visualiser') && grid.canMutate) {\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n      gridWrapper\n        .querySelector(`div[id=\"${DOMEle.id}\"]`)\n        .classList.add('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = true;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n      gridWrapper\n        .querySelector(`div[id=\"${DOMEle.id}\"]`)\n        .classList.remove('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = false;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isStart) {\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isEnd) {\n      prevEle = DOMEle;\n    }\n  }\n}\n\ngridWrapper.addEventListener('mouseover', handleMouseover);\n\nfunction handleMouseover(e) {\n  if (!e.target.classList.contains('visualiser') && grid.canMutate) {\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.target != prevEle) {\n      if (e.buttons === 1 && prevEle.classList.contains('start-node')) {\n        prevEle.classList.remove('start-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isStart = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n\n        current.classList.add('start-node');\n        grid[gridCoords[0]][gridCoords[1]].isStart = true;\n        grid.startNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n        if (grid.previousAlgo)\n          findPathOnStartOrEndNodeMouseDrag(grid.previousAlgo);\n      } else if (e.buttons === 1 && prevEle.classList.contains('end-node')) {\n        prevEle.classList.remove('end-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isEnd = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n        current.classList.add('end-node');\n        grid[gridCoords[0]][gridCoords[1]].isEnd = true;\n        grid.endNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n        if (grid.previousAlgo)\n          findPathOnStartOrEndNodeMouseDrag(grid.previousAlgo);\n      } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n        gridWrapper\n          .querySelector(`div[id=\"${DOMEle.id}\"]`)\n          .classList.remove('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n        prevEle = DOMEle;\n      } else if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n        gridWrapper\n          .querySelector(`div[id=\"${DOMEle.id}\"]`)\n          .classList.add('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = true;\n        prevEle = DOMEle;\n      }\n    }\n  }\n}\n\nfunction findPathOnStartOrEndNodeMouseDrag(value) {\n  if (grid.canMutate) {\n    const prevAnimationSpeed = grid.animationSpeed;\n    grid.animationSpeed = 0;\n    switch (value) {\n      case 'a*':\n        clearVisited();\n        aStar();\n        break;\n      case 'dfs':\n        clearVisited();\n        depthFirstSearch();\n        break;\n      case 'bfs':\n        clearVisited();\n        breadthFirstSearch();\n        break;\n      case 'gbfs':\n        clearVisited();\n        greedyBreadthFirstSearch();\n        break;\n      case 'bdbfs':\n        clearVisited();\n        biDirectionalBreadthFirstSearch();\n        break;\n\n      default:\n        return;\n    }\n    grid.animationSpeed = prevAnimationSpeed;\n  }\n}\n\nconst closeTutorialBtnArray = document.querySelectorAll('.close-tutorial');\n\ntutorialBtn.addEventListener('click', () => {\n  const tutorialTransparencyLayer = document.querySelector(\n    '.tutorial-transparency-layer'\n  );\n  tutorialTransparencyLayer.classList.add('visible');\n\n  for (let closeBtn of closeTutorialBtnArray) {\n    closeBtn.addEventListener('click', () => {\n      tutorialTransparencyLayer.classList.remove('visible');\n    });\n  }\n});\n\nconst tutorialNextAndPrevBtns = document.querySelectorAll(\n  '.tutorial-switcher-btn'\n);\n\nfor (let btn of tutorialNextAndPrevBtns) {\n  btn.addEventListener('click', handleNextAndPreTutorialClick);\n}\n\nfunction handleNextAndPreTutorialClick(e) {\n  const pageChangeBtn = e.currentTarget;\n  const tutorialWrapper = document.querySelector('.tutorial-wrapper');\n\n  for (let i = 0; i < tutorialWrapper.children.length; i++) {\n    if (tutorialWrapper.children[i].classList.contains('visible')) {\n      var currVisChildIdx = i;\n      break;\n    }\n  }\n\n  tutorialWrapper.children[currVisChildIdx].classList.remove('visible');\n\n  if (pageChangeBtn.classList[0] === 'next-tutorial-slide') {\n    currVisChildIdx + 1 < tutorialWrapper.children.length\n      ? tutorialWrapper.children[currVisChildIdx + 1].classList.add('visible')\n      : tutorialWrapper.children[0].classList.add('visible');\n  } else {\n    currVisChildIdx > 0\n      ? tutorialWrapper.children[currVisChildIdx - 1].classList.add('visible')\n      : tutorialWrapper.children[\n          tutorialWrapper.children.length - 1\n        ].classList.add('visible');\n  }\n}\n\n//-----------------------------------------------------------------------------\n//\n//=============================================================================\n//\n//------------------------GRAPH ALGO'S AND HELPER FUCNTIONS--------------------\n//\n//=============================================================================s\n//\n//-----------------------------------------------------------------------------\n\nfunction randInt(max, min = 0) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction generateWallsRandom() {\n  const height = grid.length - 1;\n  const width = grid[0].length - 1;\n\n  const totalWalls = (height * width) / 3;\n  const nodesToAnimate = [];\n  nodesToAnimate.push('add wall');\n\n  for (let i = 0; i < totalWalls; i++) {\n    const y = randInt(height);\n    const x = randInt(width);\n    if (grid[y][x].isWall || grid[y][x].isStart || grid[y][x].isEnd) {\n      i--;\n    } else {\n      nodesToAnimate.push(grid[y][x]);\n    }\n  }\n  animateNodes(nodesToAnimate);\n}\n\n//-----------------------------------------------------\n//Create Walls Recursive Backtracker and heler function\n//-----------------------------------------------------\n\nfunction chooseOrientation(width, height) {\n  if (width < height) {\n    return 'horizontal';\n  } else if (height < width) {\n    return 'vertical';\n  } else {\n    return Math.floor(Math.random() * 2) ? 'horizontal' : 'vertical';\n  }\n}\n\nfunction generateWallsRecursiveDivision() {\n  const wallsToAnimate = [];\n  wallsToAnimate.push('add wall');\n  const previousHoles = grid.map((row) => row.map((node) => false));\n\n  grid.forEach((row, yIndex) =>\n    row.forEach((node, xIndex) => {\n      if (yIndex === 0 || yIndex === grid.length - 1) wallsToAnimate.push(node);\n      else if (xIndex === 0 || xIndex === row.length - 1)\n        wallsToAnimate.push(node);\n    })\n  );\n\n  // const reversedBottomRow = wallsToAnimate.splice(-grid[0].length).reverse();\n  // wallsToAnimate.concat(reversedBottomRow);\n  // console.log(wallsToAnimate);\n\n  const firstYStart = 1;\n  const firstYEnd = grid.length - 2;\n  const firstXStart = 1;\n  const firstXEnd = grid[0].length - 2;\n\n  const orientation = chooseOrientation(\n    firstXEnd - firstXStart,\n    firstYEnd - firstYStart\n  );\n  divide(firstYStart, firstYEnd, firstXStart, firstXEnd, orientation);\n  animateNodes(wallsToAnimate);\n\n  function divide(yStart, yEnd, xStart, xEnd, orient) {\n    const width = xEnd - xStart + 1;\n    const height = yEnd - yStart + 1;\n\n    //prevents walls right next to eachother\n    if (width < 2 || height < 2 || height * width < 5) return;\n\n    if (orient === 'horizontal') {\n      const yDivideCoord = randInt(yEnd - 1, yStart + 1);\n      let holeCoord;\n\n      if (previousHoles[yDivideCoord][xStart - 1]) {\n        holeCoord = xStart;\n      } else if (previousHoles[yDivideCoord][xEnd + 1]) {\n        holeCoord = xEnd;\n      } else {\n        holeCoord = Math.random() > 0.5 ? xStart : xEnd;\n        // holeCoord = randInt(xEnd, xStart);\n      }\n\n      for (let i = xStart; i <= xEnd; i++) {\n        if (\n          grid[yDivideCoord][i].isStart ||\n          grid[yDivideCoord][i].isEnd ||\n          i === holeCoord\n        ) {\n          previousHoles[yDivideCoord][i] = true;\n        }\n        if (previousHoles[yDivideCoord][i]) continue;\n\n        wallsToAnimate.push(grid[yDivideCoord][i]);\n      }\n\n      //topside\n      let orient = chooseOrientation(width, yDivideCoord - yStart);\n      divide(yStart, yDivideCoord - 1, xStart, xEnd, orient);\n\n      //bottomside\n      orient = chooseOrientation(width, yEnd - yDivideCoord);\n      divide(yDivideCoord + 1, yEnd, xStart, xEnd, orient);\n    } else {\n      const xDivideCoord = randInt(xEnd - 1, xStart + 1);\n\n      let holeCoord;\n      if (previousHoles[yStart - 1][xDivideCoord]) {\n        holeCoord = yStart;\n      } else if (previousHoles[yEnd + 1][xDivideCoord]) {\n        holeCoord = yEnd;\n      } else {\n        holeCoord = Math.random() > 0.5 ? yStart : yEnd;\n        // holeCoord = randInt(yEnd, yStart);\n      }\n\n      for (let i = yStart; i <= yEnd; i++) {\n        if (\n          grid[i][xDivideCoord].isStart ||\n          grid[i][xDivideCoord].isEnd ||\n          i === holeCoord\n        ) {\n          previousHoles[i][xDivideCoord] = true;\n        }\n        if (previousHoles[i][xDivideCoord]) continue;\n\n        wallsToAnimate.push(grid[i][xDivideCoord]);\n      }\n\n      //divide left side\n      let orient = chooseOrientation(xDivideCoord - xStart, height);\n      divide(yStart, yEnd, xStart, xDivideCoord - 1, orient);\n\n      //divide right side\n      orient = chooseOrientation(xEnd - xDivideCoord, height);\n      divide(yStart, yEnd, xDivideCoord + 1, xEnd, orient);\n    }\n  }\n}\n\n//-------------------------------------------------------------------------\n//Create walls Recursive Backtracker and helper function\n//-------------------------------------------------------------------------\n\nfunction getRecursiveBacktrackerUnvisitedNeighbors(\n  currentX,\n  currentY,\n  visited\n) {\n  let possibleNeighbors = [\n    [currentY - 2, currentX],\n    [currentY, currentX + 2],\n    [currentY + 2, currentX],\n    [currentY, currentX - 2],\n  ];\n\n  let neighbors = [];\n\n  for (let i = 0; i < possibleNeighbors.length; i++) {\n    let [y, x] = possibleNeighbors[i];\n    if (y < 0 || y > grid.length - 1 || x < 0 || x > grid[0].length - 1)\n      continue;\n    if (visited[y][x]) continue;\n\n    neighbors.push([y, x]);\n  }\n  if (neighbors.length > 0) {\n    const nextIdx = Math.floor(Math.random() * neighbors.length);\n    return neighbors[nextIdx];\n  } else {\n    return;\n  }\n}\n\nfunction generateMazeRecursiveBacktracker(startX, startY) {\n  grid.map((row) =>\n    row.map((node) => {\n      if (node.isStart || node.isEnd) return;\n\n      node.isWall = true;\n      node.DOMRef.classList.add('wall-node');\n    })\n  );\n\n  const visited = grid.map((row) => row.map((_) => false));\n  visited[startY][startX] = true;\n\n  const nodesToAddWall = [];\n  nodesToAddWall.push('remove wall');\n  const stack = [];\n  let [currentY, currentX] = [startY, startX];\n\n  while (true) {\n    let next = getRecursiveBacktrackerUnvisitedNeighbors(\n      currentX,\n      currentY,\n      visited\n    );\n    nodesToAddWall.push(grid[currentY][currentX]);\n\n    if (next) {\n      stack.push(next);\n\n      let [nextY, nextX] = next;\n      visited[nextY][nextX] = true;\n      let inbetweenWall;\n      if (currentX === nextX) {\n        if (currentY > nextY) {\n          inbetweenWall = [currentY - 1, currentX];\n        } else {\n          inbetweenWall = [currentY + 1, currentX];\n        }\n      } else if (currentY === nextY) {\n        if (currentX > nextX) {\n          inbetweenWall = [currentY, currentX - 1];\n        } else {\n          inbetweenWall = [currentY, currentX + 1];\n        }\n      }\n\n      nodesToAddWall.push(grid[inbetweenWall[0]][inbetweenWall[1]]);\n\n      currentY = nextY;\n      currentX = nextX;\n    } else {\n      if (stack.length > 0) {\n        next = stack.pop();\n\n        [currentY, currentX] = next;\n      } else {\n        break;\n      }\n    }\n  }\n  animateNodes(nodesToAddWall);\n}\n\n//horizontal manhattan distance from Greedy bfs and A* search\n\nfunction manhattanDist(yCurrent, xCurrent, yEnd, xEnd) {\n  return Math.abs(yEnd - yCurrent) + Math.abs(xEnd - xCurrent);\n}\n\nfunction greedyBreadthFirstSearch() {\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n  const visited = grid.map((row) => row.map((node) => false));\n  const horizDist = grid.map((row) => row.map((node) => Infinity));\n  const prev = grid.map((row) => row.map((node) => null));\n\n  const priorityQueue = new MinHeap();\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  let currentHorizDist = manhattanDist(\n    startNode.y,\n    startNode.x,\n    endNode.y,\n    endNode.x\n  );\n\n  priorityQueue.insert([currentHorizDist, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentHorizDist, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      let newHorizDist = manhattanDist(\n        neighbor.y,\n        neighbor.x,\n        endNode.y,\n        endNode.x\n      );\n      if (newHorizDist < horizDist[neighbor.y][neighbor.x]) {\n        horizDist[neighbor.y][neighbor.x] = newHorizDist;\n        priorityQueue.insert([newHorizDist, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction aStar() {\n  const visitedNodesToDisplay = [];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n\n  const visited = grid.map((row) => row.map((node) => false));\n  const prev = grid.map((row) => row.map((node) => null));\n  const horizDist = grid.map((row) => row.map((node) => Infinity));\n\n  horizDist[startNode.y][startNode.x] = 0;\n  const weight = 1;\n  let currentHorizDist = manhattanDist(\n    startNode.y,\n    startNode.x,\n    endNode.y,\n    endNode.x\n  );\n\n  const priorityQueue = new MinHeap();\n  priorityQueue.insert([0, startNode]);\n  visitedNodesToDisplay.push('visited');\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentGlobalCost, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      break;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(\n      (n) => n && !n.isWall\n    );\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      const newNeighborDist = horizDist[currentNode.y][currentNode.x] + weight;\n      const neighborHorizDist = manhattanDist(\n        neighbor.y,\n        neighbor.x,\n        endNode.y,\n        endNode.x\n      );\n      const newGlobalCost = newNeighborDist + neighborHorizDist;\n\n      if (\n        newGlobalCost <\n        horizDist[neighbor.y][neighbor.x] + neighborHorizDist\n      ) {\n        horizDist[neighbor.y][neighbor.x] = newNeighborDist;\n        priorityQueue.insert([newGlobalCost, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction breadthFirstSearch() {\n  const queue = [];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map((row) => row.map((n) => null));\n  const visited = grid.map((row) => row.map((n) => false));\n\n  queue.push(startNode);\n\n  while (queue.length) {\n    const currentNode = queue.shift();\n    visited[currentNode.y][currentNode.x] = true;\n\n    // nodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      visited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      prev[neighbor.y][neighbor.x] = currentNode;\n      queue.push(neighbor);\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction biDirectionalBreadthFirstSearch() {\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const startNodeQueue = [];\n  const startNodePrev = grid.map((row) => row.map((_) => null));\n  const startVisited = grid.map((row) => row.map((_) => false));\n  startNodeQueue.push(startNode);\n\n  const endNodeQueue = [];\n  const endNodePrev = grid.map((row) => row.map((_) => null));\n  const endVisited = grid.map((row) => row.map((_) => false));\n  endNodeQueue.push(endNode);\n\n  while (endNodeQueue.length && startNodeQueue.length) {\n    const currentEndNode = endNodeQueue.shift();\n    const currentStartNode = startNodeQueue.shift();\n    let intersection;\n\n    for (let y = 0; y < startVisited.length; y++) {\n      for (let x = 0; x < startVisited[0].length; x++) {\n        if (startVisited[y][x] && endVisited[y][x]) {\n          intersection = grid[y][x];\n          break;\n        }\n      }\n    }\n\n    if (intersection) {\n      const shortestPathStart = getShortestPath(\n        intersection,\n        startNodePrev,\n        startNode\n      );\n      shortestPathStart.unshift('path');\n      shortestPathStart.push(intersection);\n\n      const shortestPathEnd = getShortestPath(\n        intersection,\n        endNodePrev,\n        endNode\n      );\n\n      const pathNodesToDisplay = shortestPathStart.concat(\n        shortestPathEnd.reverse()\n      );\n      animateNodes(visitedNodesToDisplay.concat(pathNodesToDisplay));\n      return;\n    }\n\n    const startNeighbors = Object.values(\n      currentStartNode.getNeighbors()\n    ).filter((n) => n && !n.isWall);\n    const endNeighbors = Object.values(\n      currentEndNode.getNeighborsReversed()\n    ).filter((n) => n && !n.isWall);\n\n    for (let neighbor of startNeighbors) {\n      if (startVisited[neighbor.y][neighbor.x]) continue;\n\n      startVisited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      startNodePrev[neighbor.y][neighbor.x] = currentStartNode;\n      startNodeQueue.push(neighbor);\n    }\n\n    for (let neighbor of endNeighbors) {\n      if (endVisited[neighbor.y][neighbor.x]) continue;\n\n      endVisited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      endNodePrev[neighbor.y][neighbor.x] = currentEndNode;\n      endNodeQueue.push(neighbor);\n    }\n  }\n\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction depthFirstSearch() {\n  const stack = [];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map((row) => row.map(() => null));\n  const visited = grid.map((row) => row.map(() => false));\n  visited[startNode.y][startNode.x];\n\n  stack.push(startNode);\n\n  while (stack.length) {\n    const currentNode = stack.pop();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      prev[neighbor.y][neighbor.x] = currentNode;\n      stack.push(neighbor);\n      // break;\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction getShortestPath(currentNode, prevArray, startNode) {\n  const shortestPath = [];\n  while (true) {\n    if (prevArray[currentNode.y][currentNode.x] == startNode) break;\n\n    shortestPath.unshift(prevArray[currentNode.y][currentNode.x]);\n    currentNode = prevArray[currentNode.y][currentNode.x];\n  }\n  return shortestPath;\n}\n\nfunction animateNodes(nodesArray) {\n  const removeWallAnimation = [\n    { transform: 'scale(1.2)', offset: 0.75 },\n    { backgroundColor: 'hsl(0, 0%, 100%)' },\n  ];\n  const wallAnimation = [\n    { transform: 'scale(1.2)', offset: 0.75 },\n    { backgroundColor: 'hsla(240, 23%, 8%, 0.9)' },\n  ];\n  const visitedAnimation = [\n    { transform: 'scale(.2)' },\n    {\n      borderRadius: '50%',\n      backgroundColor: 'hsl(281, 53%, 24%)',\n      offset: 0.25,\n    },\n    { transform: 'scale(1.2)', offset: 0.7 },\n  ];\n  const pathAnimation = [\n    { transform: 'scale(.5)' },\n    { backgroundColor: 'hsla(115, 41%, 30%, 0.397)', offset: 0.5 },\n    { transform: 'scale(1.2)', offset: 0.75 },\n  ];\n\n  const speed = grid.animationSpeed;\n  let nodeTypeToAnimate;\n\n  for (let i = 0; i < nodesArray.length; i++) {\n    const currentNode = nodesArray[i];\n\n    if (typeof currentNode === 'string') {\n      nodeTypeToAnimate = currentNode;\n      continue;\n    }\n\n    if (nodeTypeToAnimate === 'add wall') {\n      if (speed === 0) {\n        currentNode.isWall = true;\n        currentNode.DOMRef.classList.add('wall-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.isWall = true;\n          currentNode.DOMRef.classList.add('wall-node');\n\n          currentNode.DOMRef.animate(wallAnimation, 400);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'remove wall') {\n      if (speed === 0) {\n        currentNode.isWall = false;\n        currentNode.DOMRef.classList.remove('wall-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.isWall = false;\n          currentNode.DOMRef.classList.remove('wall-node');\n          currentNode.DOMRef.animate(removeWallAnimation, 400);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'visited') {\n      if (speed === 0) {\n        currentNode.visited = true;\n        currentNode.DOMRef.classList.add('visited');\n        if (i === nodesArray.length - 1 && !nodesArray.includes('path')) {\n          grid.canMutate = true;\n        }\n      } else {\n        setTimeout(() => {\n          currentNode.visited = true;\n          currentNode.DOMRef.classList.add('visited');\n          currentNode.DOMRef.animate(visitedAnimation, 500);\n          if (i === nodesArray.length - 1 && !nodesArray.includes('path')) {\n            grid.canMutate = true;\n          }\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'path') {\n      if (speed === 0) {\n        currentNode.DOMRef.classList.add('path-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.DOMRef.classList.add('path-node');\n          currentNode.DOMRef.animate(pathAnimation, 500);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    }\n  }\n}\n\n/* function djikstra() {\n  const visited = grid.map(row => row.map(node => false));\n  const weight = grid.map(row => row.map(node => (node.isWeight) ? 10 : 1 ));\n  const dist = grid.map(row => row.map(node => Infinity));\n  const prev = grid.map(row => row.map(node => null));\n  const visitedNodesToDisplay = [];\n\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n\n  dist[startNode.y][startNode.x] = 0;\n  const priorityQueue = new MinHeap;\n\n  priorityQueue.insert([0, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentDist, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n    console.log(priorityQueue.heap);\n\n\n\n    if (currentNode == endNode) {\n      animateNodes(visitedNodesToDisplay, 'visited');\n      console.log(prev);\n      break;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(n => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (const neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) {\n        console.log('passed');\n        continue;\n      }\n\n      let newDistance = currentDist + weight[neighbor.y][neighbor.x];\n\n      if (newDistance < dist[neighbor.y][neighbor.x]) {\n        dist[neighbor.y][neighbor.x] = newDistance;\n        priorityQueue.insert([newDistance, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n\n} */\n\n//incase I find out how to stop two animateNodes loop running\n//at the same time\n/* function animateNodes(nodesArray, type, reverse = false) {\n  const speed = grid.animationSpeed;\n\n  switch (type) {\n    case 'wall':\n      let wallAnimation;\n      reverse\n        ? (wallAnimation = [\n            { transform: 'scale(1.2)', offset: 0.75 },\n            { backgroundColor: 'hsl(0, 0%, 100%)' },\n          ])\n        : [\n            { transform: 'scale(1.2)', offset: 0.75 },\n            { backgroundColor: 'hsla(240, 23%, 8%, 0.9)' },\n          ];\n\n      for (let i = 0; i < nodesArray.length; i++) {\n        const currentNode = nodesArray[i];\n        if (speed === 0) {\n          reverse ? (currentNode.isWall = false) : (currentNode.isWall = true);\n          reverse\n            ? currentNode.DOMRef.classList.remove('wall-node')\n            : currentNode.DOMRef.classList.add('wall-node');\n          reverse\n            ? currentNode.DOMRef.animate(wallAnimation, 400)\n            : currentNode.DOMRef.animate(wallAnimation, 400);\n        } else {\n          setTimeout(() => {\n            reverse\n              ? (currentNode.isWall = false)\n              : (currentNode.isWall = true);\n            reverse\n              ? currentNode.DOMRef.classList.remove('wall-node')\n              : currentNode.DOMRef.classList.add('wall-node');\n            reverse\n              ? currentNode.DOMRef.animate(wallAnimation, 400)\n              : currentNode.DOMRef.animate(wallAnimation, 400);\n          }, speed * i);\n        }\n      }\n      return true;\n\n    case 'visited':\n      const visitedAnimation = [\n        { transform: 'scale(.2)' },\n        {\n          borderRadius: '50%',\n          backgroundColor: 'hsl(281, 53%, 24%)',\n          offset: 0.25,\n        },\n        { transform: 'scale(1.2)', offset: 0.7 },\n      ];\n\n      for (let i = 0; i < nodesArray.length; i++) {\n        const currentNode = nodesArray[i];\n        if (speed === 0) {\n          currentNode.visited = true;\n          currentNode.DOMRef.classList.add('visited');\n        } else {\n          setTimeout(() => {\n            console.log(i, nodesArray.length);\n            currentNode.visited = true;\n            currentNode.DOMRef.classList.add('visited');\n            currentNode.DOMRef.animate(visitedAnimation, 400);\n          }, speed * i);\n        }\n      }\n      return true;\n\n    case 'path':\n      const pathAnimation = [\n        { transform: 'scale(.5)' },\n        { backgroundColor: 'hsla(115, 41%, 30%, 0.397)', offset: 0.5 },\n        { transform: 'scale(1.2)', offset: 0.75 },\n      ];\n      for (let i = 0; i < nodesArray.length; i++) {\n        const node = nodesArray[i];\n        if (speed === 0) {\n          node.DOMRef.classList.add('path-node');\n        } else {\n          setTimeout(() => {\n            node.DOMRef.classList.add('path-node');\n            node.DOMRef.animate(pathAnimation, 400);\n          }, speed * i);\n        }\n      }\n\n    default:\n      return;\n  }\n} */\n"]}