{"version":3,"sources":["js/DataStructures.js","js/GraphAlgorithms.js","js/index.js"],"names":["grid","animationSpeed","canMutate","previousAlgo","Node","id","index","split","map","n","Number","x","y","visited","isWall","isStart","isEnd","DOMRef","length","up","right","down","left","MinHeap","Math","floor","heap","idx1","idx2","tmp","element","push","idx","parent","swap","root","shift","unshift","pop","heapify","leftChild","rightChild","biggest","randInt","max","min","random","generateWallsRandom","height","width","totalWalls","nodesToAnimate","i","animateNodes","chooseOrientation","generateWallsRecursiveDivision","wallsToAnimate","previousHoles","row","node","forEach","yIndex","xIndex","firstYStart","firstYEnd","firstXEnd","divide","yStart","yEnd","xStart","xEnd","orient","yDivideCoord","holeCoord","xDivideCoord","getRecursiveBacktrackerUnvisitedNeighbors","currentX","currentY","possibleNeighbors","neighbors","generateMazeRecursiveBacktracker","startX","startY","classList","add","_","nodesToAddWall","stack","next","nextY","nextX","inbetweenWall","manhattanDist","yCurrent","xCurrent","abs","greedyBreadthFirstSearch","visitedNodesToDisplay","horizDist","Infinity","prev","priorityQueue","startNode","endNode","currentHorizDist","insert","isEmpty","extractMin","currentNode","shortestPath","getShortestPath","concat","Object","values","getNeighbors","filter","neighbor","newHorizDist","aStar","weight","newNeighborDist","neighborHorizDist","newGlobalCost","breadthFirstSearch","queue","biDirectionalBreadthFirstSearch","startNodeQueue","startNodePrev","startVisited","endNodeQueue","endNodePrev","endVisited","currentEndNode","currentStartNode","intersection","shortestPathStart","shortestPathEnd","pathNodesToDisplay","reverse","startNeighbors","endNeighbors","getNeighborsReversed","depthFirstSearch","prevArray","nodesArray","removeWallAnimation","nodeTypeToAnimate","transform","offset","backgroundColor","wallAnimation","visitedAnimation","borderRadius","pathAnimation","speed","setTimeout","animate","remove","includes","gridSizeSlider","document","querySelector","gridWrapper","clearBtn","animationSpeedBtn","pathfindingDropdownBtn","mazeGenDroptdownBtn","tutorialBtn","algoBtns","querySelectorAll","mobileMenuRevealBtn","getElementById","dropdownContainers","createGrid","maxRowOrColLength","visualiserWrapper","wrapperWidth","clientWidth","wrapperHeight","clientHeight","onMobile","nodesInEachRow","round","nodesInEachCol","divWidth","divHeight","Array","div","createElement","setAttribute","style","margin","append","handleGridSizeInputSlider","empty","parseInt","value","setStartEndNodes","handleWindowResizeHandlePageLoad","window","innerWidth","clearBoard","clearVisited","gridWidth","gridHeight","startAndEndY","endX","ceil","HTMLElement","prototype","firstChild","removeChild","addEventListener","e","target","innerHTML","prevEle","handleMousedown","preventDefault","contains","DOMEle","buttons","gridCoords","handleMouseover","prevGridCoords","current","findPathOnStartOrEndNodeMouseDrag","prevAnimationSpeed","closeTutorialBtnArray","tutorialTransparencyLayer","tutorialNextAndPrevBtns","btn","handleNextAndPrevTutorialClick","pageChangeBtn","currentTarget","tutorialWrapper","children","currVisChildIdx","parentNode","blur","stopPropagation","toggle","container","eleWithOpenClass"],"mappings":"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","file":"js.c0a8b866.js","sourceRoot":"../src","sourcesContent":["const grid = [];\ngrid.animationSpeed = 5;\ngrid.canMutate = true;\ngrid.previousAlgo = null;\n\nclass Node {\n  constructor(id) {\n    this.id = id;\n    this.index = id.split('-').map((n) => Number(n));\n    this.x = [...this.index][1];\n    this.y = [...this.index][0];\n    this.visited = false;\n    this.isWall = false;\n    this.isStart = false;\n    this.isEnd = false;\n    this.DOMRef;\n  }\n\n  up() {\n    if (this.y <= 0) {\n      return null;\n    } else {\n      return grid[this.y - 1][this.x];\n    }\n  }\n\n  right() {\n    if (this.x >= grid[0].length - 1) {\n      return null;\n    } else {\n      return grid[this.y][this.x + 1];\n    }\n  }\n\n  down() {\n    if (this.y >= grid.length - 1) {\n      return null;\n    } else {\n      return grid[this.y + 1][this.x];\n    }\n  }\n\n  left() {\n    if (this.x <= 0) {\n      return null;\n    } else {\n      return grid[this.y][this.x - 1];\n    }\n  }\n\n  getNeighbors() {\n    return {\n      up: this.up(),\n      right: this.right(),\n      down: this.down(),\n      left: this.left(),\n    };\n  }\n\n  getNeighborsReversed() {\n    return {\n      left: this.left(),\n      down: this.down(),\n      right: this.right(),\n      up: this.up(),\n    };\n  }\n}\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  swap(idx1, idx2) {\n    const tmp = this.heap[idx1];\n    this.heap[idx1] = this.heap[idx2];\n    this.heap[idx2] = tmp;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  insert(element) {\n    this.heap.push(element);\n\n    let idx = this.heap.length - 1;\n\n    while (idx !== 0 && this.heap[idx][0] < this.heap[this.parent(idx)][0]) {\n      this.swap(idx, this.parent(idx));\n      idx = this.parent(idx);\n    }\n  }\n\n  extractMin() {\n    //remove ele from the front of the heap\n    const root = this.heap.shift();\n\n    //put the last element to the front of the heap and remove the last element from the\n    //heap as it is now sitting at the front of the heap\n    this.heap.unshift(this.heap[this.heap.length - 1]);\n    this.heap.pop();\n\n    this.heapify(0);\n    return root;\n  }\n\n  heapify(idx) {\n    let left = this.leftChild(idx);\n    let right = this.rightChild(idx);\n    let biggest = idx;\n\n    //if left node is bigger than the current node\n    if (left < this.heap.length && this.heap[biggest][0] > this.heap[left][0]) {\n      biggest = left;\n    }\n\n    //if the right child is bigger than the curr node\n    if (\n      right < this.heap.length &&\n      this.heap[biggest][0] > this.heap[right][0]\n    ) {\n      biggest = right;\n    }\n\n    //if the value of the smallest has changed, then swap\n    if (biggest != idx) {\n      this.swap(biggest, idx);\n      this.heapify(biggest);\n    }\n  }\n\n  leftChild = (index) => index * 2 + 1;\n  rightChild = (index) => index * 2 + 2;\n  parent = (index) => Math.floor((index - 1) / 2);\n}\n\nexport { MinHeap, Node, grid };\n","import { MinHeap, grid } from './DataStructures';\n\n//-----------------------------------------------------------------------------\n//\n//=============================================================================\n//\n//------------------------GRAPH ALGO'S AND HELPER FUCNTIONS--------------------\n//\n//=============================================================================\n//\n//-----------------------------------------------------------------------------\n\nfunction randInt(max, min = 0) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction generateWallsRandom() {\n  const height = grid.length - 1;\n  const width = grid[0].length - 1;\n\n  const totalWalls = (height * width) / 3;\n  const nodesToAnimate = [];\n  nodesToAnimate.push('add wall');\n\n  for (let i = 0; i < totalWalls; i++) {\n    const y = randInt(height);\n    const x = randInt(width);\n    if (grid[y][x].isWall || grid[y][x].isStart || grid[y][x].isEnd) {\n      i--;\n    } else {\n      nodesToAnimate.push(grid[y][x]);\n    }\n  }\n  animateNodes(nodesToAnimate);\n}\n\n//-----------------------------------------------------\n//Create Walls Recursive Backtracker and helper function\n//-----------------------------------------------------\n\nfunction chooseOrientation(width, height) {\n  if (width < height) {\n    return 'horizontal';\n  } else if (height < width) {\n    return 'vertical';\n  } else {\n    return Math.floor(Math.random() * 2) ? 'horizontal' : 'vertical';\n  }\n}\n\nfunction generateWallsRecursiveDivision() {\n  const wallsToAnimate = [];\n  wallsToAnimate.push('add wall');\n  const previousHoles = grid.map((row) => row.map((node) => false));\n\n  grid.forEach((row, yIndex) =>\n    row.forEach((node, xIndex) => {\n      if (yIndex === 0 || yIndex === grid.length - 1) wallsToAnimate.push(node);\n      else if (xIndex === 0 || xIndex === row.length - 1)\n        wallsToAnimate.push(node);\n    })\n  );\n\n  // const reversedBottomRow = wallsToAnimate.splice(-grid[0].length).reverse();\n  // wallsToAnimate.concat(reversedBottomRow);\n  // console.log(wallsToAnimate);\n\n  const firstYStart = 1;\n  const firstYEnd = grid.length - 2;\n  const firstXStart = 1;\n  const firstXEnd = grid[0].length - 2;\n\n  const orientation = chooseOrientation(\n    firstXEnd - firstXStart,\n    firstYEnd - firstYStart\n  );\n  divide(firstYStart, firstYEnd, firstXStart, firstXEnd, orientation);\n  animateNodes(wallsToAnimate);\n\n  function divide(yStart, yEnd, xStart, xEnd, orient) {\n    const width = xEnd - xStart + 1;\n    const height = yEnd - yStart + 1;\n\n    //prevents walls right next to eachother\n    if (width < 2 || height < 2 || height * width < 5) return;\n\n    if (orient === 'horizontal') {\n      const yDivideCoord = randInt(yEnd - 1, yStart + 1);\n      let holeCoord;\n\n      if (previousHoles[yDivideCoord][xStart - 1]) {\n        holeCoord = xStart;\n      } else if (previousHoles[yDivideCoord][xEnd + 1]) {\n        holeCoord = xEnd;\n      } else {\n        holeCoord = Math.random() > 0.5 ? xStart : xEnd;\n        // holeCoord = randInt(xEnd, xStart);\n      }\n\n      for (let i = xStart; i <= xEnd; i++) {\n        if (\n          grid[yDivideCoord][i].isStart ||\n          grid[yDivideCoord][i].isEnd ||\n          i === holeCoord\n        ) {\n          previousHoles[yDivideCoord][i] = true;\n        }\n        if (previousHoles[yDivideCoord][i]) continue;\n\n        wallsToAnimate.push(grid[yDivideCoord][i]);\n      }\n\n      //topside\n      let orient = chooseOrientation(width, yDivideCoord - yStart);\n      divide(yStart, yDivideCoord - 1, xStart, xEnd, orient);\n\n      //bottomside\n      orient = chooseOrientation(width, yEnd - yDivideCoord);\n      divide(yDivideCoord + 1, yEnd, xStart, xEnd, orient);\n    } else {\n      const xDivideCoord = randInt(xEnd - 1, xStart + 1);\n\n      let holeCoord;\n      if (previousHoles[yStart - 1][xDivideCoord]) {\n        holeCoord = yStart;\n      } else if (previousHoles[yEnd + 1][xDivideCoord]) {\n        holeCoord = yEnd;\n      } else {\n        holeCoord = Math.random() > 0.5 ? yStart : yEnd;\n        // holeCoord = randInt(yEnd, yStart);\n      }\n\n      for (let i = yStart; i <= yEnd; i++) {\n        if (\n          grid[i][xDivideCoord].isStart ||\n          grid[i][xDivideCoord].isEnd ||\n          i === holeCoord\n        ) {\n          previousHoles[i][xDivideCoord] = true;\n        }\n        if (previousHoles[i][xDivideCoord]) continue;\n\n        wallsToAnimate.push(grid[i][xDivideCoord]);\n      }\n\n      //divide left side\n      let orient = chooseOrientation(xDivideCoord - xStart, height);\n      divide(yStart, yEnd, xStart, xDivideCoord - 1, orient);\n\n      //divide right side\n      orient = chooseOrientation(xEnd - xDivideCoord, height);\n      divide(yStart, yEnd, xDivideCoord + 1, xEnd, orient);\n    }\n  }\n}\n\n//-------------------------------------------------------------------------\n//Create walls Recursive Backtracker and helper function\n//-------------------------------------------------------------------------\n\nfunction getRecursiveBacktrackerUnvisitedNeighbors(\n  currentX,\n  currentY,\n  visited\n) {\n  let possibleNeighbors = [\n    [currentY - 2, currentX],\n    [currentY, currentX + 2],\n    [currentY + 2, currentX],\n    [currentY, currentX - 2],\n  ];\n\n  let neighbors = [];\n\n  for (let i = 0; i < possibleNeighbors.length; i++) {\n    let [y, x] = possibleNeighbors[i];\n    if (y < 0 || y > grid.length - 1 || x < 0 || x > grid[0].length - 1)\n      continue;\n    if (visited[y][x]) continue;\n\n    neighbors.push([y, x]);\n  }\n  if (neighbors.length > 0) {\n    const nextIdx = Math.floor(Math.random() * neighbors.length);\n    return neighbors[nextIdx];\n  } else {\n    return;\n  }\n}\n\nfunction generateMazeRecursiveBacktracker(startX, startY) {\n  grid.map((row) =>\n    row.map((node) => {\n      if (node.isStart || node.isEnd) return;\n\n      node.isWall = true;\n      node.DOMRef.classList.add('wall-node');\n    })\n  );\n\n  const visited = grid.map((row) => row.map((_) => false));\n  visited[startY][startX] = true;\n\n  const nodesToAddWall = [];\n  nodesToAddWall.push('remove wall');\n  const stack = [];\n  let [currentY, currentX] = [startY, startX];\n\n  while (true) {\n    let next = getRecursiveBacktrackerUnvisitedNeighbors(\n      currentX,\n      currentY,\n      visited\n    );\n    nodesToAddWall.push(grid[currentY][currentX]);\n\n    if (next) {\n      stack.push(next);\n\n      let [nextY, nextX] = next;\n      visited[nextY][nextX] = true;\n      let inbetweenWall;\n      if (currentX === nextX) {\n        if (currentY > nextY) {\n          inbetweenWall = [currentY - 1, currentX];\n        } else {\n          inbetweenWall = [currentY + 1, currentX];\n        }\n      } else if (currentY === nextY) {\n        if (currentX > nextX) {\n          inbetweenWall = [currentY, currentX - 1];\n        } else {\n          inbetweenWall = [currentY, currentX + 1];\n        }\n      }\n\n      nodesToAddWall.push(grid[inbetweenWall[0]][inbetweenWall[1]]);\n\n      currentY = nextY;\n      currentX = nextX;\n    } else {\n      if (stack.length > 0) {\n        next = stack.pop();\n\n        [currentY, currentX] = next;\n      } else {\n        break;\n      }\n    }\n  }\n  animateNodes(nodesToAddWall);\n}\n\n//horizontal manhattan distance from Greedy bfs and A* search\n\nfunction manhattanDist(yCurrent, xCurrent, yEnd, xEnd) {\n  return Math.abs(yEnd - yCurrent) + Math.abs(xEnd - xCurrent);\n}\n\nfunction greedyBreadthFirstSearch() {\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n  const visited = grid.map((row) => row.map((node) => false));\n  const horizDist = grid.map((row) => row.map((node) => Infinity));\n  const prev = grid.map((row) => row.map((node) => null));\n\n  const priorityQueue = new MinHeap();\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  let currentHorizDist = manhattanDist(\n    startNode.y,\n    startNode.x,\n    endNode.y,\n    endNode.x\n  );\n\n  priorityQueue.insert([currentHorizDist, startNode]);\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentHorizDist, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      let newHorizDist = manhattanDist(\n        neighbor.y,\n        neighbor.x,\n        endNode.y,\n        endNode.x\n      );\n      if (newHorizDist < horizDist[neighbor.y][neighbor.x]) {\n        horizDist[neighbor.y][neighbor.x] = newHorizDist;\n        priorityQueue.insert([newHorizDist, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction aStar() {\n  const visitedNodesToDisplay = [];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n\n  const visited = grid.map((row) => row.map((node) => false));\n  const prev = grid.map((row) => row.map((node) => null));\n  const horizDist = grid.map((row) => row.map((node) => Infinity));\n\n  horizDist[startNode.y][startNode.x] = 0;\n  const weight = 1;\n  let currentHorizDist = manhattanDist(\n    startNode.y,\n    startNode.x,\n    endNode.y,\n    endNode.x\n  );\n\n  const priorityQueue = new MinHeap();\n  priorityQueue.insert([0, startNode]);\n  visitedNodesToDisplay.push('visited');\n\n  while (!priorityQueue.isEmpty()) {\n    const [currentGlobalCost, currentNode] = priorityQueue.extractMin();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      break;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter(\n      (n) => n && !n.isWall\n    );\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      const newNeighborDist = horizDist[currentNode.y][currentNode.x] + weight;\n      const neighborHorizDist = manhattanDist(\n        neighbor.y,\n        neighbor.x,\n        endNode.y,\n        endNode.x\n      );\n      const newGlobalCost = newNeighborDist + neighborHorizDist;\n\n      if (\n        newGlobalCost <\n        horizDist[neighbor.y][neighbor.x] + neighborHorizDist\n      ) {\n        horizDist[neighbor.y][neighbor.x] = newNeighborDist;\n        priorityQueue.insert([newGlobalCost, neighbor]);\n        prev[neighbor.y][neighbor.x] = currentNode;\n      }\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction breadthFirstSearch() {\n  const queue = [];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map((row) => row.map((n) => null));\n  const visited = grid.map((row) => row.map((n) => false));\n\n  queue.push(startNode);\n\n  while (queue.length) {\n    const currentNode = queue.shift();\n    visited[currentNode.y][currentNode.x] = true;\n\n    // nodesToDisplay.push(currentNode);\n\n    if (currentNode === endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      visited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      prev[neighbor.y][neighbor.x] = currentNode;\n      queue.push(neighbor);\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction biDirectionalBreadthFirstSearch() {\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const startNodeQueue = [];\n  const startNodePrev = grid.map((row) => row.map((_) => null));\n  const startVisited = grid.map((row) => row.map((_) => false));\n  startNodeQueue.push(startNode);\n\n  const endNodeQueue = [];\n  const endNodePrev = grid.map((row) => row.map((_) => null));\n  const endVisited = grid.map((row) => row.map((_) => false));\n  endNodeQueue.push(endNode);\n\n  while (endNodeQueue.length && startNodeQueue.length) {\n    const currentEndNode = endNodeQueue.shift();\n    const currentStartNode = startNodeQueue.shift();\n    let intersection;\n\n    for (let y = 0; y < startVisited.length; y++) {\n      for (let x = 0; x < startVisited[0].length; x++) {\n        if (startVisited[y][x] && endVisited[y][x]) {\n          intersection = grid[y][x];\n          break;\n        }\n      }\n    }\n\n    if (intersection) {\n      const shortestPathStart = getShortestPath(\n        intersection,\n        startNodePrev,\n        startNode\n      );\n      shortestPathStart.unshift('path');\n      shortestPathStart.push(intersection);\n\n      const shortestPathEnd = getShortestPath(\n        intersection,\n        endNodePrev,\n        endNode\n      );\n\n      const pathNodesToDisplay = shortestPathStart.concat(\n        shortestPathEnd.reverse()\n      );\n      animateNodes(visitedNodesToDisplay.concat(pathNodesToDisplay));\n      return;\n    }\n\n    const startNeighbors = Object.values(\n      currentStartNode.getNeighbors()\n    ).filter((n) => n && !n.isWall);\n    const endNeighbors = Object.values(\n      currentEndNode.getNeighborsReversed()\n    ).filter((n) => n && !n.isWall);\n\n    for (let neighbor of startNeighbors) {\n      if (startVisited[neighbor.y][neighbor.x]) continue;\n\n      startVisited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      startNodePrev[neighbor.y][neighbor.x] = currentStartNode;\n      startNodeQueue.push(neighbor);\n    }\n\n    for (let neighbor of endNeighbors) {\n      if (endVisited[neighbor.y][neighbor.x]) continue;\n\n      endVisited[neighbor.y][neighbor.x] = true;\n      visitedNodesToDisplay.push(neighbor);\n      endNodePrev[neighbor.y][neighbor.x] = currentEndNode;\n      endNodeQueue.push(neighbor);\n    }\n  }\n\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction depthFirstSearch() {\n  const stack = [];\n  const visitedNodesToDisplay = [];\n  visitedNodesToDisplay.push('visited');\n\n  const endNode = grid[grid.endNode[0]][grid.endNode[1]];\n  const startNode = grid[grid.startNode[0]][grid.startNode[1]];\n\n  const prev = grid.map((row) => row.map(() => null));\n  const visited = grid.map((row) => row.map(() => false));\n  visited[startNode.y][startNode.x];\n\n  stack.push(startNode);\n\n  while (stack.length) {\n    const currentNode = stack.pop();\n    visited[currentNode.y][currentNode.x] = true;\n    visitedNodesToDisplay.push(currentNode);\n\n    if (currentNode == endNode) {\n      const shortestPath = getShortestPath(currentNode, prev, startNode);\n      shortestPath.unshift('path');\n      animateNodes(visitedNodesToDisplay.concat(shortestPath));\n      return;\n    }\n\n    const neighbors = Object.values(currentNode.getNeighbors()).filter((n) => {\n      if (n && !n.isWall) return n;\n    });\n\n    for (let neighbor of neighbors) {\n      if (visited[neighbor.y][neighbor.x]) continue;\n\n      prev[neighbor.y][neighbor.x] = currentNode;\n      stack.push(neighbor);\n      // break;\n    }\n  }\n  animateNodes(visitedNodesToDisplay);\n}\n\nfunction getShortestPath(currentNode, prevArray, startNode) {\n  const shortestPath = [];\n  while (true) {\n    if (prevArray[currentNode.y][currentNode.x] == startNode) break;\n\n    shortestPath.unshift(prevArray[currentNode.y][currentNode.x]);\n    currentNode = prevArray[currentNode.y][currentNode.x];\n  }\n  return shortestPath;\n}\n\nfunction animateNodes(nodesArray) {\n  const removeWallAnimation = [\n    { transform: 'scale(1.2)', offset: 0.75 },\n    { backgroundColor: 'hsl(0, 0%, 100%)' },\n  ];\n  const wallAnimation = [\n    { transform: 'scale(1.2)', offset: 0.75 },\n    { backgroundColor: 'hsla(240, 23%, 8%, 0.9)' },\n  ];\n  const visitedAnimation = [\n    { transform: 'scale(.2)' },\n    {\n      borderRadius: '50%',\n      backgroundColor: 'hsl(281, 53%, 24%)',\n      offset: 0.25,\n    },\n    { transform: 'scale(1.2)', offset: 0.7 },\n  ];\n  const pathAnimation = [\n    { transform: 'scale(.5)' },\n    { backgroundColor: 'hsla(115, 41%, 30%, 0.397)', offset: 0.5 },\n    { transform: 'scale(1.2)', offset: 0.75 },\n  ];\n\n  const speed = grid.animationSpeed;\n  let nodeTypeToAnimate;\n\n  for (let i = 0; i < nodesArray.length; i++) {\n    const currentNode = nodesArray[i];\n\n    if (typeof currentNode === 'string') {\n      nodeTypeToAnimate = currentNode;\n      continue;\n    }\n\n    if (nodeTypeToAnimate === 'add wall') {\n      if (speed === 0) {\n        currentNode.isWall = true;\n        currentNode.DOMRef.classList.add('wall-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.isWall = true;\n          currentNode.DOMRef.classList.add('wall-node');\n\n          currentNode.DOMRef.animate(wallAnimation, 400);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'remove wall') {\n      if (speed === 0) {\n        currentNode.isWall = false;\n        currentNode.DOMRef.classList.remove('wall-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.isWall = false;\n          currentNode.DOMRef.classList.remove('wall-node');\n          currentNode.DOMRef.animate(removeWallAnimation, 400);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'visited') {\n      if (speed === 0) {\n        currentNode.visited = true;\n        currentNode.DOMRef.classList.add('visited');\n        if (i === nodesArray.length - 1 && !nodesArray.includes('path')) {\n          grid.canMutate = true;\n        }\n      } else {\n        setTimeout(() => {\n          currentNode.visited = true;\n          currentNode.DOMRef.classList.add('visited');\n          currentNode.DOMRef.animate(visitedAnimation, 500);\n          if (i === nodesArray.length - 1 && !nodesArray.includes('path')) {\n            grid.canMutate = true;\n          }\n        }, speed * i);\n      }\n    } else if (nodeTypeToAnimate === 'path') {\n      if (speed === 0) {\n        currentNode.DOMRef.classList.add('path-node');\n        if (i === nodesArray.length - 1) grid.canMutate = true;\n      } else {\n        setTimeout(() => {\n          currentNode.DOMRef.classList.add('path-node');\n          currentNode.DOMRef.animate(pathAnimation, 500);\n          if (i === nodesArray.length - 1) grid.canMutate = true;\n        }, speed * i);\n      }\n    }\n  }\n}\n\nexport {\n  generateWallsRandom,\n  generateWallsRecursiveDivision,\n  generateMazeRecursiveBacktracker,\n  aStar,\n  greedyBreadthFirstSearch,\n  biDirectionalBreadthFirstSearch,\n  breadthFirstSearch,\n  depthFirstSearch,\n};\n","import { Node, grid } from './DataStructures.js';\nimport {\n  generateWallsRandom,\n  generateWallsRecursiveDivision,\n  generateMazeRecursiveBacktracker,\n  aStar,\n  greedyBreadthFirstSearch,\n  biDirectionalBreadthFirstSearch,\n  breadthFirstSearch,\n  depthFirstSearch,\n} from './GraphAlgorithms';\n\nconst gridSizeSlider = document.querySelector('#grid-size-slider');\nconst gridWrapper = document.querySelector('.visualiser');\nconst clearBtn = document.querySelector('#clear-board');\nconst animationSpeedBtn = document.querySelector('#animation-speed');\nconst pathfindingDropdownBtn = document.querySelector('#pathfinding-dropdown');\nconst mazeGenDroptdownBtn = document.querySelector('#maze-dropdown');\nconst tutorialBtn = document.querySelector('#help');\nconst algoBtns = document.querySelectorAll('.algo-btn');\nconst mobileMenuRevealBtn = document.getElementById('sm-controls-menu');\nconst dropdownContainers = document.querySelectorAll('.dropdown-container');\n\n//helper method for clearing all DOM element child nodes\nHTMLElement.prototype.empty = function () {\n  while (this.firstChild) {\n    this.removeChild(this.firstChild);\n  }\n};\n\n//----------------------------------------------------------\n//\n//\n//EVENT LISTENERS & UI FUNCTIONS\n//\n//\n//------------------------------------------------------------\n\n//load nodes onto page\ndocument.addEventListener('DOMContentLoaded', () => {\n  handleWindowResizeHandlePageLoad();\n});\n\nfunction createGrid(maxRowOrColLength, visualiserWrapper) {\n  const wrapperWidth = visualiserWrapper.clientWidth;\n  const wrapperHeight = visualiserWrapper.clientHeight;\n\n  const onMobile = wrapperHeight / wrapperWidth > 1.25;\n\n  const nodesInEachRow = onMobile\n    ? Math.round(maxRowOrColLength * 0.45)\n    : maxRowOrColLength;\n\n  const nodesInEachCol = onMobile\n    ? maxRowOrColLength\n    : Math.round(maxRowOrColLength * 0.45);\n\n  let divWidth = Math.floor((wrapperWidth / nodesInEachRow) * 1000) / 1000;\n  let divHeight = Math.floor((wrapperHeight / nodesInEachCol) * 1000) / 1000;\n  divWidth = divWidth - 0.05;\n  divHeight = divHeight - 0.03;\n\n  for (let y = 0; y < nodesInEachCol; y++) {\n    grid.push(new Array());\n    for (let x = 0; x < nodesInEachRow; x++) {\n      const div = document.createElement('div');\n      div.classList.add('node');\n      div.setAttribute('id', y + '-' + x);\n      div.style.width = divWidth + 'px';\n      div.style.height = divHeight + 'px';\n      div.style.margin = 'auto';\n      visualiserWrapper.append(div);\n\n      grid[y].push(new Node(`${y}-${x}`));\n      grid[y][x].DOMRef = div;\n    }\n  }\n}\n\n//update grid and populte dom with divs as range slider is updated and on page load\ngridSizeSlider.addEventListener('input', handleGridSizeInputSlider);\n\nfunction handleGridSizeInputSlider() {\n  if (grid.canMutate) {\n    grid.canMutate = false;\n    grid.length = 0;\n    gridWrapper.empty();\n    createGrid(parseInt(gridSizeSlider.value), gridWrapper);\n    setStartEndNodes();\n    grid.canMutate = true;\n  }\n}\n\nfunction handleWindowResizeHandlePageLoad() {\n  if (window.innerWidth < 401 && gridSizeSlider.value != '30') {\n    gridSizeSlider.value = '30';\n  } else if (\n    window.innerWidth > 400 &&\n    window.innerWidth < 550 &&\n    gridSizeSlider.value != '40'\n  ) {\n    gridSizeSlider.value = '40';\n  }\n\n  handleGridSizeInputSlider();\n}\n\nwindow.addEventListener('resize', handleWindowResizeHandlePageLoad);\n\npathfindingDropdownBtn.addEventListener('mousedown', (e) => {\n  if (grid.canMutate && e.target?.value) {\n    grid.canMutate = false;\n\n    switch (e.target.value) {\n      case 'a*':\n        grid.previousAlgo = 'a*';\n        clearVisited();\n        aStar();\n        break;\n      case 'dfs':\n        grid.previousAlgo = 'dfs';\n        clearVisited();\n        depthFirstSearch();\n        break;\n      case 'bfs':\n        grid.previousAlgo = 'bfs';\n        clearVisited();\n        breadthFirstSearch();\n        break;\n      case 'gbfs':\n        grid.previousAlgo = 'gbfs';\n        clearVisited();\n        greedyBreadthFirstSearch();\n        break;\n      case 'bdbfs':\n        grid.previousAlgo = 'bdbfs';\n        clearVisited();\n        biDirectionalBreadthFirstSearch();\n        break;\n\n      default:\n        return;\n    }\n  }\n});\n\nmazeGenDroptdownBtn.addEventListener('mousedown', (e) => {\n  if (grid.canMutate && e.target?.value) {\n    grid.canMutate = false;\n\n    switch (e.target.id) {\n      case 'recursive-backtracker':\n        clearBoard();\n        generateMazeRecursiveBacktracker(5, 5);\n        break;\n      case 'recursive-division':\n        clearBoard();\n        generateWallsRecursiveDivision();\n        break;\n      case 'random-walls':\n        clearBoard();\n        generateWallsRandom();\n        break;\n      default:\n        return;\n    }\n  }\n});\n\nanimationSpeedBtn.addEventListener('mousedown', (e) => {\n  switch (e.target.value) {\n    case 'fast':\n      //change from fast to slow on click\n      e.target.value = 'slow';\n      e.target.innerHTML = 'Animations: Slow';\n      grid.animationSpeed = 15;\n      break;\n\n    case 'slow':\n      //change from slow to none on click\n      e.target.value = 'instant';\n      e.target.innerHTML = 'Animations: None';\n      grid.animationSpeed = 0;\n      break;\n\n    default:\n      //change from none to fast on click\n      e.target.value = 'fast';\n      e.target.innerHTML = 'Animations: Fast';\n      grid.animationSpeed = 5;\n      break;\n  }\n});\n\nclearBtn.addEventListener('click', () => {\n  if (grid.canMutate) {\n    grid.previousAlgo = null;\n    clearBoard();\n  }\n});\n\nfunction clearBoard() {\n  grid.map((row) =>\n    row.map((node) => {\n      node.isWall = false;\n      node.visited = false;\n      node.DOMRef.classList.remove('wall-node');\n      node.DOMRef.classList.remove('visited');\n      node.DOMRef.classList.remove('path-node');\n    })\n  );\n}\n\nfunction clearVisited() {\n  grid.map((row) =>\n    row.map((node) => {\n      node.visited = false;\n      node.DOMRef.classList.remove('visited');\n      node.DOMRef.classList.remove('path-node');\n    })\n  );\n}\n\nfunction setStartEndNodes() {\n  const gridWidth = grid[0].length - 1;\n  const gridHeight = grid.length - 1;\n\n  const startAndEndY = Math.floor(gridHeight / 2);\n  const startX = Math.floor(0.15 * gridWidth);\n  const endX = Math.ceil(0.85 * gridWidth);\n\n  grid[startAndEndY][startX].isStart = true;\n  grid[startAndEndY][startX].DOMRef.classList.add('start-node');\n  grid.startNode = [startAndEndY, startX];\n\n  grid[startAndEndY][endX].isEnd = true;\n  grid[startAndEndY][endX].DOMRef.classList.add('end-node');\n  grid.endNode = [startAndEndY, endX];\n}\n\n//inital value\nlet prevEle = gridWrapper.querySelector('div[id=\"0-0\"]');\n\ngridWrapper.addEventListener('mousedown', handleMousedown);\n\nfunction handleMousedown(e) {\n  e.preventDefault();\n  if (!e.target.classList.contains('visualiser') && grid.canMutate) {\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n      gridWrapper\n        .querySelector(`div[id=\"${DOMEle.id}\"]`)\n        .classList.add('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = true;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n      gridWrapper\n        .querySelector(`div[id=\"${DOMEle.id}\"]`)\n        .classList.remove('wall-node');\n      const gridCoords = DOMEle.id.split('-');\n      grid[gridCoords[0]][gridCoords[1]].isWall = false;\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isStart) {\n      prevEle = DOMEle;\n    } else if (e.buttons === 1 && isEnd) {\n      prevEle = DOMEle;\n    }\n  }\n}\n\ngridWrapper.addEventListener('mouseover', handleMouseover);\n\nfunction handleMouseover(e) {\n  if (!e.target.classList.contains('visualiser') && grid.canMutate) {\n    const DOMEle = e.target;\n    const isWall = e.target.classList.contains('wall-node');\n    const isStart = e.target.classList.contains('start-node');\n    const isEnd = e.target.classList.contains('end-node');\n\n    if (e.target != prevEle) {\n      if (e.buttons === 1 && prevEle.classList.contains('start-node')) {\n        prevEle.classList.remove('start-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isStart = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n\n        current.classList.add('start-node');\n        grid[gridCoords[0]][gridCoords[1]].isStart = true;\n        grid.startNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n        if (grid.previousAlgo)\n          findPathOnStartOrEndNodeMouseDrag(grid.previousAlgo);\n      } else if (e.buttons === 1 && prevEle.classList.contains('end-node')) {\n        prevEle.classList.remove('end-node');\n        const prevGridCoords = prevEle.id.split('-');\n        grid[prevGridCoords[0]][prevGridCoords[1]].isEnd = false;\n\n        const current = gridWrapper.querySelector(`div[id=\"${DOMEle.id}\"]`);\n        const gridCoords = current.id.split('-');\n        current.classList.add('end-node');\n        grid[gridCoords[0]][gridCoords[1]].isEnd = true;\n        grid.endNode = [parseInt(gridCoords[0]), parseInt(gridCoords[1])];\n\n        current.classList.remove('wall-node');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n\n        prevEle = DOMEle;\n\n        if (grid.previousAlgo)\n          findPathOnStartOrEndNodeMouseDrag(grid.previousAlgo);\n      } else if (e.buttons === 1 && isWall && !isStart && !isEnd) {\n        gridWrapper\n          .querySelector(`div[id=\"${DOMEle.id}\"]`)\n          .classList.remove('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = false;\n        prevEle = DOMEle;\n      } else if (e.buttons === 1 && !isWall && !isStart && !isEnd) {\n        gridWrapper\n          .querySelector(`div[id=\"${DOMEle.id}\"]`)\n          .classList.add('wall-node');\n        const gridCoords = DOMEle.id.split('-');\n        grid[gridCoords[0]][gridCoords[1]].isWall = true;\n        prevEle = DOMEle;\n      }\n    }\n  }\n}\n\nfunction findPathOnStartOrEndNodeMouseDrag(value) {\n  if (grid.canMutate) {\n    const prevAnimationSpeed = grid.animationSpeed;\n    grid.animationSpeed = 0;\n    switch (value) {\n      case 'a*':\n        clearVisited();\n        aStar();\n        break;\n      case 'dfs':\n        clearVisited();\n        depthFirstSearch();\n        break;\n      case 'bfs':\n        clearVisited();\n        breadthFirstSearch();\n        break;\n      case 'gbfs':\n        clearVisited();\n        greedyBreadthFirstSearch();\n        break;\n      case 'bdbfs':\n        clearVisited();\n        biDirectionalBreadthFirstSearch();\n        break;\n\n      default:\n        return;\n    }\n    grid.animationSpeed = prevAnimationSpeed;\n  }\n}\n\nconst closeTutorialBtnArray = document.querySelectorAll('.close-tutorial');\n\ntutorialBtn.addEventListener('click', () => {\n  const tutorialTransparencyLayer = document.querySelector(\n    '.tutorial-transparency-layer'\n  );\n  tutorialTransparencyLayer.classList.add('visible');\n\n  for (let closeBtn of closeTutorialBtnArray) {\n    closeBtn.addEventListener('click', () => {\n      tutorialTransparencyLayer.classList.remove('visible');\n    });\n  }\n});\n\nconst tutorialNextAndPrevBtns = document.querySelectorAll(\n  '.tutorial-switcher-btn'\n);\n\nfor (let btn of tutorialNextAndPrevBtns) {\n  btn.addEventListener('click', handleNextAndPrevTutorialClick);\n}\n\nfunction handleNextAndPrevTutorialClick(e) {\n  const pageChangeBtn = e.currentTarget;\n  const tutorialWrapper = document.querySelector('.tutorial-wrapper');\n\n  for (let i = 0; i < tutorialWrapper.children.length; i++) {\n    if (tutorialWrapper.children[i].classList.contains('visible')) {\n      var currVisChildIdx = i;\n      break;\n    }\n  }\n\n  tutorialWrapper.children[currVisChildIdx].classList.remove('visible');\n\n  if (pageChangeBtn.classList[0] === 'next-tutorial-slide') {\n    currVisChildIdx + 1 < tutorialWrapper.children.length\n      ? tutorialWrapper.children[currVisChildIdx + 1].classList.add('visible')\n      : tutorialWrapper.children[0].classList.add('visible');\n  } else {\n    currVisChildIdx > 0\n      ? tutorialWrapper.children[currVisChildIdx - 1].classList.add('visible')\n      : tutorialWrapper.children[\n          tutorialWrapper.children.length - 1\n        ].classList.add('visible');\n  }\n}\n\nalgoBtns.forEach((btn) => {\n  btn.addEventListener('mouseup', (e) => {\n    e.target.id != 'animation-speed' &&\n      document.getElementById('controls-menu').classList.remove('mobile-open');\n    e.target.parentNode.parentNode.parentNode.classList.remove('open');\n    e.target.blur();\n    e.preventDefault();\n  });\n});\n\nmobileMenuRevealBtn.addEventListener('mousedown', (e) => {\n  e.stopPropagation();\n  e.preventDefault();\n  document.getElementById('controls-menu').classList.toggle('mobile-open');\n});\n\ndropdownContainers.forEach((container) => {\n  container.addEventListener('click', (e) => {\n    e.target.classList.toggle('open');\n  });\n});\n\ndocument.addEventListener('mouseup', (e) => {\n  const eleWithOpenClass = document.querySelector('.open');\n\n  if (!eleWithOpenClass || eleWithOpenClass === e.target) return;\n  else if (eleWithOpenClass) {\n    const children = [...eleWithOpenClass.querySelectorAll('*')];\n    if (!children.includes(e.target)) {\n      eleWithOpenClass.classList.remove('open');\n    }\n  }\n});\n"]}